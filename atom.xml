<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leeon Notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lijundong.com/"/>
  <updated>2017-08-07T02:56:14.000Z</updated>
  <id>http://lijundong.com/</id>
  
  <author>
    <name>leeon</name>
    <email>leeonfield@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】高性能 React：提高性能的 3 个开发工具</title>
    <link href="http://lijundong.com/translation-High-Performance-React-3-New-Tools-to-Speed-Up-Your-Apps/"/>
    <id>http://lijundong.com/translation-High-Performance-React-3-New-Tools-to-Speed-Up-Your-Apps/</id>
    <published>2017-08-06T12:31:49.000Z</published>
    <updated>2017-08-07T02:56:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82" target="_blank" rel="external">High Performance React: 3 New Tools to Speed Up Your Apps</a><br>文中介绍了几种 React 应用性能检测工具，并且提供了几条关于应用性能提升的解决方案。</p>
</blockquote>
<a id="more"></a>
<p><img src="http://source.lijundong.com/17-8-6/93104397.jpg" alt=""></p>
<p>React 通常都是非常快的，只不过一些小错误很容易会导致性能问题，组件挂载慢、组件树过深以及无意义的渲染周期等因素都会导致用户使用时感觉很慢。</p>
<h3 id="工具-1：Chrome-的-Performance-时间轴"><a href="#工具-1：Chrome-的-Performance-时间轴" class="headerlink" title="工具#1：Chrome 的 Performance 时间轴"></a>工具#1：Chrome 的 Performance 时间轴</h3><p>React 15.4 引入了一个新的 Performance 时间轴功能，它可以让你准确查看组件的挂载、更新以及卸载的过程，还能可视化相关组件的生命周期。<br><strong>注意：</strong>因为该功能使用了尚未完全适配的 <code>User Timing API</code>，所以目前只适用于 Chrome、Edge、以及 IE。</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><ol>
<li>在 Chrome 中访问你的页面，并且在 URL 后添加一个参数：<code>react_perf</code>，例如：<code>http://localhost:3000?react_perf</code></li>
<li>打开 Chrome 调试面板，进入 <strong>Performance</strong> 选项，点击  <strong>Record</strong></li>
<li>执行一些你想分析的操作</li>
<li>停止 <strong>Recording</strong></li>
<li>检查时间轴中生成的可视化图表</li>
</ol>
<p><img src="http://source.lijundong.com/17-8-6/84131199.jpg" alt=""></p>
<h4 id="查看检测结果"><a href="#查看检测结果" class="headerlink" title="查看检测结果"></a>查看检测结果</h4><p>每个彩条代表着一个组件占用的时间，因为 Javascript 是单线程的，当一个组件正在挂载或渲染时，它会占用主进程并且会阻止其他代码运行。</p>
<p>像 <code>[update]</code> 一类被包在括号中的文字描述了组件当前的状态，即组件正处于生命周期的哪一阶段。时间轴会分解出每个过程，因此你可以看到类似于 <code>[componentDidMount]</code>、<code>[componentWillReceiveProps]</code>、<code>[ctor]</code> （构造函数)、以及 <code>[render]</code> 等方法占用的时间。</p>
<p>堆叠到一起的彩条代表组建树，虽然在 React 中经常见到非常深的组件树，但如果你优化一些频繁挂载的组件，则可以减少包装组件的数量，而每少一个组件都会减少性能以及内存的损耗。</p>
<p>这里需要注意的是，时间轴中展示的消耗时间是 React 开发环境编译的效果，会比生产环境慢很多。事实上， 使用 Performance 时间轴本身也会拖慢页面的速度。虽然这些时间不能代表页面在实际生产环境中的表现，但<strong>不同组件之间的相对时间是准确的</strong>，此外，组件是否更新与页面是否是处于生产环境，这两者之间也无关联。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例#1"></a>示例#1</h4><p>为了例子生动好玩，我在 TodoMVC 项目中恶意制造了一些严重的性能问题，你可以<a href="https://perf-demo.firebaseapp.com/?react_perf" target="_blank" rel="external">在这里试试</a><br>在页面中打开调试工具，在 <strong>Performance</strong> 选项中点选 <strong>Record</strong>，然后可以在页面添加一些 TODO，停止 <strong>Record</strong>，检查时间轴，看看你能不能定位页面中造成性能问题的组件 :)。</p>
<h3 id="工具-2：why-did-you-update"><a href="#工具-2：why-did-you-update" class="headerlink" title="工具#2：why-did-you-update"></a>工具#2：why-did-you-update</h3><p>无意义的渲染周期是造成 React 性能问题的最常见的原因之一，React 默认状态下，如果父组件渲染，子组件即便属性值没有改变也会重新渲染。<br>举个例子，现有子组件如下：</p>
<pre><code>class DumbComponent extends Component {
      render() {
    return &lt;div&gt; {this.props.value} &lt;/div&gt;;
      }
}
</code></pre><p>父组件如下所示：</p>
<pre><code>class Parent extends Component {
      render() {
          return &lt;div&gt;
              &lt;DumbComponent value={3} /&gt;
          &lt;/div&gt;;
      }
}
</code></pre><p>不管父组件什么时候渲染，<code>DumbComponent</code> 都会重新渲染，不管它的属性值有没有改变。</p>
<p>通常，如果 <code>render</code> 函数执行了，但虚拟 DOM 没有任何改变，就意味此渲染周期是浪费的，无意义的，<code>render</code> 方法应该是纯净并且没有任何副作用的，在庞大的 React 项目中，要检测可能造成这些问题的代码会非常棘手，但比较方便的是，现在有个现成的工具可以用。</p>
<h4 id="使用-why-did-you-update"><a href="#使用-why-did-you-update" class="headerlink" title="使用 why-did-you-update"></a>使用 why-did-you-update</h4><p><img src="http://source.lijundong.com/17-8-6/19890189.jpg" alt=""></p>
<p><code>why-did-you-update</code> 是一个挂钩到 React 的库，可以检测一些潜在的不必要的组件渲染，它可以检测到组件属性值没变但却重新渲染的情况。</p>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><ol>
<li>用 npm 安装：<code>npm i --save-dev why-did-you-update</code></li>
<li>把下面这段代码放到页面中，位置不限：<pre><code>import React from &apos;react&apos;
if (process.env.NODE\_ENV !== &apos;production&apos;) {
      const {whyDidYouUpdate} = require(&apos;why-did-you-update&apos;)
      whyDidYouUpdate(React)
}
</code></pre></li>
</ol>
<p><strong>注意：</strong> <code>why-did-you-update</code> 虽然在开发环境下非常好用，但是一定要确保在上线前注释或删除这段代码，否则它会拖慢页面速度。</p>
<h4 id="查看检测结果-1"><a href="#查看检测结果-1" class="headerlink" title="查看检测结果"></a>查看检测结果</h4><p>当项目运行时，<code>why-did-you-update</code> 监控页面并且打印出没必要改变的组件，并展示这些组件渲染周期前后的属性值。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例#2"></a>示例#2</h4><p>为了演示，我在 TodoMVC 项目里安装了 <code>why-did-you-update</code>，并放在了 Code Sandbox 平台上（一个线上 React 平台），打开浏览器的 console，在页面中添加一些 ToDo，你就会看到控制台输出的问题。</p>
<p><a href="https://codesandbox.io/s/xGJP4QExn" target="_blank" rel="external">这里是项目</a>。</p>
<p>需要注意的是，项目中的一些组件存在无意义渲染，试试上面的方式来杜绝那些无意义的组件渲染，如果你处理正确的话，控制台中应该没有 <code>why-did-you-update</code> 输出的警告。</p>
<h3 id="React-开发工具"><a href="#React-开发工具" class="headerlink" title="React 开发工具"></a>React 开发工具</h3><p><img src="http://source.lijundong.com/17-8-6/18745991.jpg" alt=""></p>
<p>Chrome 扩展“React Developer Tools”已经内建了更新组件的高亮功能，这对于定位无意义的组件渲染是非常有用的，要使用功能，首先得<a href="https://codesandbox.io/s/xGJP4QExn" target="_blank" rel="external">安装 React Developer Tools 扩展</a><br>安装后，在调试面板中进入 React 选项狂，打开 “Highlight Updates” 功能。</p>
<p><img src="http://source.lijundong.com/17-8-6/71902719.jpg" alt=""></p>
<p>然后操作项目页面，和不同的组件进行交互，你就可以看到 React 开发工具高亮的效果了。</p>
<h4 id="查看检测结果-2"><a href="#查看检测结果-2" class="headerlink" title="查看检测结果"></a>查看检测结果</h4><p>React 开发工具高亮显示了那些在给定时间内重新渲染的组件，不同颜色的高亮对应了组件更新的频率，蓝色代表更新频率低，而颜色范围为绿黄红则代表了高频更新。<br>看到黄色或者红色不一定代表有问题，可能是调整滑动条或触发频繁更新的其他 UI 组件。但如果你点击了一个按钮却看到了红色高亮，这可能代表代码有问题了。该扩展的功能是让开发者定位项目中无意义更新的组件，作为一个开发者，你应该对给定时间内哪些组件需要更新有大概的意识。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例#3"></a>示例#3</h4><p>同上面的例子一样，为了演示更形象生动，我在 TodoMVC 项目中恶意造成了一些不必要的组件更新。<br><a href="https://highlight-demo.firebaseapp.com/" target="_blank" rel="external">TodoMVC 项目地址</a><br>打开上面的项目链接，打开 React 开发工具，并且打开 “update highlighting”，当你在输入框中输入时，你会看到所有的 Todo 条目都在高亮，如果你快速输入，你会看到高亮的颜色不同，分别代表着这些组件的更新频率。</p>
<h3 id="修复无意义渲染"><a href="#修复无意义渲染" class="headerlink" title="修复无意义渲染"></a>修复无意义渲染</h3><p>当你确定项目中的一些组件存在无意义渲染的情况时，有以下几种简单的修复方式。</p>
<h4 id="使用-PureComponent"><a href="#使用-PureComponent" class="headerlink" title="使用 PureComponent"></a>使用 PureComponent</h4><p>在上面的示例中，<code>DumbComponent</code> 想对于它的属性值是一个纯粹的函数，也就是说，该组件只需要在它的属性值改变时进行重新渲染，React 有一个内建的特殊组件 <code>PureComponent</code> 恰好适用于这种场景。<br>现用 <code>React.PureComponent</code> 取代 <code>React.Component</code>，如下所示：</p>
<pre><code>class DumbComponent extends PureComponent {
      render() {
        return &lt;div&gt; {this.props.value} &lt;/div&gt;;
      }
}
</code></pre><p>使用以上的写法，该组件就只会在属性值改变的情况下重新渲染。</p>
<p>需要注意的是，<code>PureComponent</code> 对属性值只做了<strong>浅比较</strong>，如果数据结构比较复杂，它可能会忽略一些属性的属性的改变而不让组件重新渲染。</p>
<h4 id="执行-shouldComponentUpdate"><a href="#执行-shouldComponentUpdate" class="headerlink" title="执行 shouldComponentUpdate"></a>执行 shouldComponentUpdate</h4><p><code>shouldComponentUpdate</code> 是一个组件因为属性或者状态改变而重新渲染之前被调用的组件方法，如果 <code>shouldComponentUpdate</code> 返回 <code>true</code> ，<code>render</code> 会被调用，如果返回的是 <code>false</code>, <code>render</code> 则不会被调用。<br>通过执行 <code>shouldComponentUpdate</code> 方法，你可以避免无意义的组件渲染。<br>举个例子，现在 <code>dumb</code> 组件中添加 <code>shouldComponentUpdate</code> 方法，像以下展示的写法：</p>
<pre><code>class DumbComponent extends Component {
     shouldComponentUpdate(nextProps) {
    if (this.props.value !== nextProps.value) {
          return true;
    } else {
          return false;
    }
      }
    render() {
    return &lt;div&gt;foo&lt;/div&gt;;
      }
}
</code></pre><h3 id="在生产环境调试性能问题"><a href="#在生产环境调试性能问题" class="headerlink" title="在生产环境调试性能问题"></a>在生产环境调试性能问题</h3><p>React 开发工具只在你本地起作用，但如果你想在生产环境了解项目的性能问题的话，你应该试试 <a href="https://logrocket.com/" target="_blank" rel="external">LogRocket</a></p>
<p><img src="http://source.lijundong.com/17-8-6/2564335.jpg" alt=""></p>
<p><a href="https://logrocket.com/" target="_blank" rel="external">LogRocket</a> 就像是网络应用的录像机，记录在你网站上发生的一切，你不用去猜测问题的原因，你可以重播存在 bug 或者性能问题的会话来快速定位问题的根本原因。<br>LogRocket 会记录页面的性能数据、Redux 动作／状态、日志、错误、网络请求／响应（包含响应头和响应体）以及浏览器的 metadata。也会记录页面中的 HTML 和 CSS，重新创建即使是最复杂的单页应用的非常完美的视频。</p>
<p><a href="https://logrocket.com/" target="_blank" rel="external">LogRocket | Logging and Session Replay for JavaScript Apps</a></p>
<p>感谢您的阅读，希望这些工具和技巧对你的下一个项目会有帮助！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://medium.freecodecamp.org/make-react-fast-again-tools-and-techniques-for-speeding-up-your-react-app-7ad39d3c1b82&quot;&gt;High Performance React: 3 New Tools to Speed Up Your Apps&lt;/a&gt;&lt;br&gt;文中介绍了几种 React 应用性能检测工具，并且提供了几条关于应用性能提升的解决方案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="译文" scheme="http://lijundong.com/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="react" scheme="http://lijundong.com/tags/react/"/>
    
      <category term="译文" scheme="http://lijundong.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>【译】React 的 10 种迷你开发模式</title>
    <link href="http://lijundong.com/translation-10-mini-react-patterns/"/>
    <id>http://lijundong.com/translation-10-mini-react-patterns/</id>
    <published>2017-07-30T08:18:22.000Z</published>
    <updated>2017-08-06T08:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="https://hackernoon.com/10-react-mini-patterns-c1da92f068c5" target="_blank" rel="external">10 React mini-patterns</a><br>对于 React 初学者的一些经验之谈，初次翻译，望多指教。</p>
</blockquote>
<a id="more"></a>
<p>过去几年里，我参与了几个较大的 <code>React</code> 项目，也做了非常多的小项目，在这过程中，我总结了一些 React 常用的开发模式。<br>这些模式是我在 React 入门阶段非常希望看到的，如果你是 <code>React</code> 新手，那你今天算是赚到了，如果你已经是 <code>React</code> 老鸟，不妨看看有哪些模式。本文较长，如果觉得一些介绍比较枯燥（比如 3、6、8、10），可以选择跳过。</p>
<h3 id="1-数据传输"><a href="#1-数据传输" class="headerlink" title="1. 数据传输"></a>1. 数据传输</h3><p>我建议每个 React 初学者都去了解 React 组件向下传递数据（对象、字符串等）的模式，以及传递让子组件传回数据的方法的模式。可以联想救援队将食物与对讲机送抵井底被困矿工。<br>举个例子：<br><img src="http://source.lijundong.com/17-8-3/97066388.jpg" alt="" title="Sending data down and up"></p>
<p>图中左右分别是父组件和子组件，你可以想象连接父子组件的这两个属性允许了数据的双向流通。</p>
<p>其实这一条不算真正意义上的开发模式，下面才是。</p>
<h3 id="2-修复-HTML-原生-input"><a href="#2-修复-HTML-原生-input" class="headerlink" title="2. 修复 HTML 原生 input"></a>2. 修复 HTML 原生 input</h3><p>React 和 web 组件的一大好处是，当页面出现 bug，你可以很快定位到问题所在。<br>如果你在考虑页面中使用不同的输入标签，你会发现这些标签的命名大多是无意义，因此，如果我在处理一个包含多个输入的页面时，我首先会处理这个问题。</p>
<p><img src="http://source.lijundong.com/17-8-3/93024380.jpg" alt=""></p>
<p>这些输入标签虽然不是纯粹的花架子，但是仍有很多地方可以改进：</p>
<ul>
<li>输入应该通过 <code>onChange</code> 方法返回值，而不是通过 <code>Javascript</code> 事件绑定</li>
<li>保证 <code>onChange</code> 返回值的类型与输入的值类型统一，如果 <code>typeof props.value</code> 是一个 <code>number</code> 类型，应该将 <code>e.target.value</code> 转换成 <code>number</code> 类型再返回</li>
<li>一套 <code>radio</code> 标签和一个 <code>select</code> 标签在功能上都是相同的，唯一的区别只是 UI 的不同，推荐项目中保留一个 <code>&lt;PickOneFromMany /&gt;</code> 组件，可以通过属性 <code>ui=&quot;radio&quot;</code> 或者 <code>ui=&quot;dropDown&quot;</code> 进行控制</li>
</ul>
<p>以上是我处理原生输入标签时用到的方法，你可以选择其他方式，关键是将这些原生标签转换成为你所用，再也不需要忍受那些糟糕的原生输入标签了。</p>
<h3 id="3-给-input-绑定唯一-ID-的标签"><a href="#3-给-input-绑定唯一-ID-的标签" class="headerlink" title="3. 给 input 绑定唯一 ID 的标签"></a>3. 给 input 绑定唯一 ID 的标签</h3><p>关于 <code>input</code> 输入，如果你注重用户体验，你应该给每个 <code>&lt;input&gt;</code> 标签绑定一个 <code>&lt;label&gt;</code>,通过 <code>id</code>/<code>for</code> 属性进行关联。<br>但如果给每一个 <code>input</code> 都想一个独一无二且生动形象的 ID，那样太浪费时间，而且使用随机生成 ID 的方式也不可行，客户端与服务器端生成的 ID 不同，导致校验不通过，这里推荐你创建一个提供增量 ID 的模块，并在 <code>input</code> 组件中使用，如下所示：</p>
<pre><code>class Input extends React.Component {
    constructor(props) {
        super(props);
        this.id = getNextId();
        this.onChange = this.onChange.bind(this);
  }
   onChange(e) {
        this.props.onChange(e.target.value);
  }
   render() {
       return (
       &lt;label htmlFor={this.id}&gt;
           {this.props.label}
           &lt;input
               id={this.id}
               value={this.props.value} 
               onChange={this.onChange}
               /&gt;
               &lt;/label&gt;
           );
      }
}
</code></pre><p>虽然这里解决 ID 的问题，但是这个方案有漏洞，<code>getNextId()</code> 方法每被调用一次，数字会增加，如果是在服务端渲染，这个数字会持续增加到，因此应该在每次渲染之前进行一次重置（每一次网络请求)。因此，一个完整的获取 ID 模块应该是这样：</p>
<pre><code>let count = 1;
export const resetId = () =&gt; {
    count = 1;
}
export const getNextId = () =&gt; {
    return element-id-${count++};
}
</code></pre><h3 id="4-通过-props-控制-CSS"><a href="#4-通过-props-控制-CSS" class="headerlink" title="4. 通过 props 控制 CSS"></a>4. 通过 props 控制 CSS</h3><p>当你想在不同的实例中应用不同的 CSS 样式，你可以通过传入不同的 <code>props</code> 值来控制需要应用的样式。表面上看，这样的操作似乎很简单，但实际应用中往往会出现很多错误。<br>我总结共有三种不同的方式来控制组件的样式：</p>
<h4 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h4><p>借鉴主题的思路，将一系列的 CSS 声明组合在一起，统一成一个主题，在组件中生命组件的主题，例如 <code>primary</code> 按钮以及 <code>secondary</code> 按钮：<br><code>&lt;Button theme=&quot;secondary&quot;&gt;Hello&lt;/Button&gt;</code><br>一个组件中尽量使用一个主题。</p>
<h4 id="使用标记"><a href="#使用标记" class="headerlink" title="使用标记"></a>使用标记</h4><p>也许你的页面中会有一些圆角 <code>button</code>，但这样的风格不符合你已经定义的主题，遇到这种情况，你可能要去找 UI 商量一个统一的方案，或是在元素中添加一个布尔属性，像这样：<br><code>&lt;Button theme=&quot;secondary&quot; rounded&gt;Hello&lt;/Button&gt;</code><br>等同于这种写法：<br><code>&lt;Button theme=&quot;secondary&quot; rounded={true}&gt;Hello&lt;/Button&gt;</code></p>
<h4 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h4><p>当然，你肯定会遇到直接在组建中写 CSS 样式的情况，像这样：<br><code>&lt;Icon width=&quot;25&quot; height=&quot;25&quot; type=&quot;search&quot; /&gt;</code></p>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>设想你现在需要实现一个链接，但现在有三种截然不同的主题，一些链接有下划线，一些没有，就像这样：</p>
<p><img src="http://source.lijundong.com/17-8-3/67133232.jpg" alt=""></p>
<p>下面给出我的处理方式：</p>
<pre><code>// demo.jsx
const Link = (props) =&gt; {
  let className = link link--${props.theme}-theme;
  if (!props.underline) className += &apos; link--no-underline&apos;;
  return &lt;a href={props.href} className={className}&gt;{props.children}&lt;/a&gt;;
};
Link.propTypes = {
  theme: PropTypes.oneOf([
&apos;default&apos;, // primary color, no underline
&apos;blend&apos;, // inherit surrounding styles
&apos;primary-button&apos;, // primary color, solid block
  ]),
  underline: PropTypes.bool,
  href: PropTypes.string.isRequired,
  children: PropTypes.oneOfType([
PropTypes.element,
PropTypes.array,
PropTypes.string,
  ]).isRequired,
};
Link.defaultProps = {
  theme: &apos;default&apos;,
  underline: false,
};
</code></pre><p>CSS 代码如下：</p>
<pre><code>// demo.css
.link--default-theme,
.link--blend-theme:hover {
  color: #D84315;
}

.link--blend-theme {
  color: inherit;
}

.link--default-theme:hover,
.link--blend-theme:hover {
  text-decoration: underline;
}

.link--primary-button-theme {
  display: inline-block;
  padding: 12px 25px;
  font-size: 18px;
  background: #D84315;
  color: white;
}

.link--no-underline {
  text-decoration: none;
}
</code></pre><p>你可能注意到我在类名(例如 <code>link-no-underline</code> )中使用了 <code>--</code>，源自于我过去一直以少写 CSS 代码为目标，但后来意识到这是错的。如果样式可以更好地应用在布局中，我更喜欢使用一些双重和多选择器规则集。<br>虽然我之前提过，但我还想再强调一下，扩展一个网站最困难的部分是 CSS 的部分，Javascript 部分都很容易，CSS 开始就写的很混乱，后面维护会非常困难，一入布局深似海。<br>实际项目中，一些 web 开发者往往被 CSS 特异性给难倒了，如果你在浏览网页，不妨查看一下页面中的元素（比如导航栏中的提示图标）是如何用 CSS 实现的。<br>如果你不想打开控制台去找，也可以思考这个元素（比如圆圈中包含数字）的实现样式涉及了哪些 CSS 规则。</p>
<blockquote>
<p>译者注：所说的元素包含在原文站点中</p>
</blockquote>
<p>共有二十三条规则，还不包括从其他十一条规则下集成的规则，其中 <code>line-height</code> 被复写了九次……即便 <code>line-height</code> 是一只猫，也未能幸免于难。</p>
<p><img src="http://source.lijundong.com/17-8-3/72770435.jpg" alt=""></p>
<blockquote>
<p>译者注：猫有九命的梗</p>
</blockquote>
<p>使用 React 之后，我们更好地处理页面样式，更周到地决定设计哪些类应用在我们的组件中，将全局设置迁移到 <code>Button.scss</code> 文件中，移除所有对于特异性以及文件顺序的依赖。<br>边注：我梦想有一天，我们再也不需要浏览器对于样式使用的建议。<code>::user-agent-styles: none-whatsoever;</code> 让这样的梦想成为现实。</p>
<h3 id="5-开关组件"><a href="#5-开关组件" class="headerlink" title="5. 开关组件"></a>5. 开关组件</h3><p>开关组件是呈现众多组件之一的组件。可以是用来展示页面的 <code>&lt;Page&gt;</code> 组件或者是 tab 集合中的 tab，也可以是模态组件中的不同模式。<br>我过去习惯使用 switch 语句处理，实际传递到我想要渲染的组件，再从组件本身导出对组件的引用（作为命名导出，作为组件的属性）。<br>现在看来这些都是可怕的方式，我已经解决的一个潜在危险方法是我用一个对象将 prop 值映射到组件中。</p>
<pre><code>import HomePage from &apos;./HomePage.jsx&apos;;
import AboutPage from &apos;./AboutPage.jsx&apos;;
import UserPage from &apos;./UserPage.jsx&apos;;
import FourOhFourPage from &apos;./FourOhFourPage.jsx&apos;;
const PAGES = {
home: HomePage,
about: AboutPage,
user: UserPage,
};
const Page = (props) =&gt; {
const Handler = PAGES[props.page] || FourOhFourPage;
return &lt;Handler {...props} /&gt;
};
Page.propTypes = {
page: PropTypes.oneOf(Object.keys(PAGES)).isRequired,
};
</code></pre><p><code>PAGE</code> 对象中的值可以在 prop 类型中用来捕获开发时错误。当然，我们可以像这样使用 <code>&lt;Page page=&quot;home&quot; /&gt;</code>，如果你将 <code>home</code>、<code>about</code> 和 <code>user</code> 分别提换成 <code>/</code>、<code>/about</code> 以及 <code>／user</code>，那么你就有了半个路由啦。<br>（下一步想法：移除 react-router）</p>
<h3 id="6-进入组件内部"><a href="#6-进入组件内部" class="headerlink" title="6. 进入组件内部"></a>6. 进入组件内部</h3><p>如果你想提高用户体验，不妨试试在页面输入较频繁的输入框添加 <code>autofocus</code>，非常简单，但却可以大大提高用户的使用体验。<br>设想页面中有一个登陆表单，而作为“用户体验高级设计师”的你想在表单的“用户名”输入框中添加一个闪烁的光标，但发现登陆表单显示在模态框中，而 <code>autofocus</code> 属性只能应用在页面加载。<br>现在你该怎么办 ？<br>你可能会用 Javascript 实现，给 <code>input</code> 标签一个 <code>id</code>，再用 <code>document.getElementById(&#39;user-name-input&#39;).focus()</code> 让输入框聚焦。这种方法虽然有效，但不够优雅，你的程序中对字符串匹配的依赖应该越少越好。<br>比较幸运的是，有一种非常简单的方法可以实现这个效果：</p>
<pre><code>class SignInModal extends Component {
  componentDidMount() {
this.InputComponent.focus();
  }
  render() {
return (
  &lt;div&gt;
&lt;label&gt;User name: &lt;/label&gt;
&lt;Input
  ref={comp =&gt; { this.InputComponent = comp; }}
/&gt;
  &lt;/div&gt;
)
  }
}
</code></pre><p>需要注意的是，当你对组件使用 <code>ref</code> 时，是对组件的引用（而不是底层元素），所以你可以访问其方法。</p>
<h3 id="7-组件的边界"><a href="#7-组件的边界" class="headerlink" title="7. 组件的边界"></a>7. 组件的边界</h3><p>设想你正在写一个搜索用户的组件，当你输入的时候，你会看到一列潜在匹配的用户名和头像，就像这样。</p>
<p><img src="http://source.lijundong.com/17-8-3/79573493.jpg" alt=""></p>
<p>当你在设计这个组件时，你可能会犹豫，列表中的每一项都属于 <code>SearchSuggestion</code> 组件吗 ？只有几行 HTML 和 CSS 代码，也许不是 ？但我曾经告诉自己：“如果感到疑惑，那就再建一个新组件”。</p>
<p>我如果这样做，就一个单独的组件都没了。相反，只有一个给每个入口返回对应 DOM 的 <code>renderSearchSuggestion</code> 方法，我就生成了如下的结果：</p>
<pre><code>const SearchSuggestions = (props) =&gt; {
  // renderSearchSuggestion() behaves as a pseduo SearchSuggestion component
  // keep it self contained and it should be easy to extract later if needed
  const renderSearchSuggestion = listItem =&gt; (
&lt;li key={listItem.id}&gt;{listItem.name} {listItem.id}&lt;/li&gt;
  );
  return (
&lt;ul&gt;
  {props.listItems.map(renderSearchSuggestion)}
&lt;/ul&gt;
  );
}
</code></pre><p>如果需求变得更复杂或者你想在其他地方使用这个组件，你可以把这段代码复制到新的组件中。</p>
<p>不要过早地组件化，组件不像茶匙，你可以有很多组件。</p>
<p>我的意思不是要你把你觉得应该独立成组件的部分合并到父组件中，而是想让你把那些你认为不应该独立成组件的部分做一些改进，让它看起来和所在的组件更贴合（如果可以的话）。</p>
<h3 id="8-用于格式化文字的组件"><a href="#8-用于格式化文字的组件" class="headerlink" title="8. 用于格式化文字的组件"></a>8. 用于格式化文字的组件</h3><p>当我刚接触 React 时，我觉得组件是一个非常大的东西，一种给 DOM 结构分组的方法，但实际上，组件就像是用于格式化的一种方法。<br>这里有一个 <code>&lt;Price&gt;</code> 组件，输入一个数字会返回一个漂亮的字符串（加上小数点或者 $ 符）。</p>
<pre><code>const Price = (props) =&gt; {
const price = props.children.toLocaleString(&apos;en&apos;, {
  style: props.showSymbol ? &apos;currency&apos; : undefined,
  currency: props.showSymbol ? &apos;USD&apos; : undefined,
  maximumFractionDigits: props.showDecimals ? 2 : 0,
});
return &lt;span className={props.className}&gt;{price}&lt;/span&gt;
};

Price.propTypes = {
  className: React.PropTypes.string,
  children: React.PropTypes.number,
  showDecimals: React.PropTypes.bool,
  showSymbol: React.PropTypes.bool,
};

Price.defaultProps = {
  children: 0,
  showDecimals: true,
  showSymbol: true,
};

const Page = () =&gt; {
  const lambPrice = 1234.567;
  const jetPrice = 999999.99;
  const bootPrice = 34.567;
  return (
&lt;div&gt;
  &lt;p&gt;One lamb is &lt;Price className=&quot;expensive&quot;&gt;{lambPrice}&lt;/Price&gt;&lt;/p&gt;
  &lt;p&gt;One jet is &lt;Price showDecimals={false}&gt;{jetPrice}&lt;/Price&gt;&lt;/p&gt;
  &lt;p&gt;Those gumboots will set ya back &lt;Price showDecimals={false} showSymbol={false}&gt;{bootPrice}&lt;/Price&gt; bucks.&lt;/p&gt;
&lt;/div&gt;
  );
};
</code></pre><p>注意：代码中没有对获取的数字进行校验……</p>
<h3 id="9-Store-服务于组件"><a href="#9-Store-服务于组件" class="headerlink" title="9. Store 服务于组件"></a>9. Store 服务于组件</h3><p>这行代码我已经写过无数遍了（虽然夸张了点）：<br><code>if (props.user.signInStatus === SIGN_IN_STATUSES.SIGNED_IN)...</code><br>最近我意识到，我这样做是不是错了，我想知道的是“用户登录了没”，而不是“用户登录的状态是否等于已登录 ？”<br>对于我的组件而言，他们应该有足够的发展，而不该因为了忧虑这些小事叨扰它们，他们不该管得到的 price 参数是否是 Number 类型，也不应该为了一个参数的 <code>true</code> 或者 <code>false</code> 烦心。<br>如你所见，如果在 <code>store</code> 中定义的数据符合你的组件要求，你的组件就会简洁很多。如我之前所说，bug 隐藏在复杂逻辑之后，你的组件越简洁，出现 bug 的几率就越低。<br>但开发中肯定会遇到一些复杂的场景，关于如何解决这些问题，我这里有几点经验：</p>
<ol>
<li>制定组件的一般结构以及其所需要的数据</li>
<li>设计满足这些需求的 <code>stroe</code></li>
<li>尽量使你传入的数据匹配 <code>stroe</code> 的要求<br>关于最后一点，我建议创建一个单独的模块来完成所有输入数据的格式处理，属性重命名、字符串转数字、对象转数组、Date 字符串转 Date 对象等等。</li>
</ol>
<h3 id="10-不要通过相对路径引入组件"><a href="#10-不要通过相对路径引入组件" class="headerlink" title="10. 不要通过相对路径引入组件"></a>10. 不要通过相对路径引入组件</h3><pre><code>import Button from &apos;../../../../Button/Button.jsx&apos;;
import Icon from &apos;../../../../Icon/Icon.jsx&apos;;
import Footer from &apos;../../Footer/Footer.jsx&apos;;
</code></pre><p>用下面的方式替代上面的引用方式，是不是觉得清爽很多 ？<br>    import {Button, Icon, Footer} from ‘Components’;<br>理论上可以这么做：</p>
<ul>
<li>创建一个 <code>index.js</code> 文件来引用你所有的组件</li>
<li>使用 Webpack 的 <code>resolve.alias</code> 来重定向所有组件到 <code>index</code> 文件<br>我目前还没尝试过这种方法，我打算在先有的项目中拿一个出来转换成这样的组织方式（蛤蛤，骗你的，我一直都是这么做的）。但正如我之前写的代码一样，我后来意识到这种方式是错的，原因如下：</li>
</ul>
<ol>
<li>Webpack 2 中的 <a href="https://github.com/webpack/webpack/issues/4160#issuecomment-281236136" target="_blank" rel="external">resolve.alias</a> 失效了</li>
<li>因为组件不在 <code>node_modules</code> 里，所以这算是一个 <code>eslint</code> 错误</li>
<li>如果你有一个好的 IDE，那么它会知道项目里的所有组件，如果你忘了加一些属性值，它会温馨地提示你添加，你可以通过 <code>cmd</code>/<code>Ctrl</code> + 点击就可以打开这些组件所在的文件。如果用我之前的方式引用组件，那么 IDE 将找不到我的组件的位置，我就失去了这些温馨智能的功能。</li>
</ol>
<p><img src="http://source.lijundong.com/17-8-3/7528192.jpg" alt=""></p>
<p>标注：<a href="https://medium.com/@hsiungmatt" target="_blank" rel="external">matthew hsiung</a> 在关于 eslint 和 WebStorm 的 issue 回复下面提供了一个<a href="https://medium.com/@hsiungmatt/great-article-917a2f6b718e#.w66jk94ao" target="_blank" rel="external">解决方案</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://hackernoon.com/10-react-mini-patterns-c1da92f068c5&quot;&gt;10 React mini-patterns&lt;/a&gt;&lt;br&gt;对于 React 初学者的一些经验之谈，初次翻译，望多指教。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="译文" scheme="http://lijundong.com/categories/%E8%AF%91%E6%96%87/"/>
    
    
      <category term="react" scheme="http://lijundong.com/tags/react/"/>
    
      <category term="译文" scheme="http://lijundong.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>llog-32</title>
    <link href="http://lijundong.com/good-coder-not-equal-to-good-developer/"/>
    <id>http://lijundong.com/good-coder-not-equal-to-good-developer/</id>
    <published>2017-07-27T13:15:51.000Z</published>
    <updated>2017-07-28T03:30:01.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>时间：2017-7-27<br>坐标：北京<br>天气：阴</p>
</blockquote>
<a id="more"></a>
<p>上午在给新上的项目排期，之前在实验室做项目阶段，最怕的就是估时间，估多了甲方不同意，估少了自己做不完，但这个问题肯定要解决，从启蒙那学了估期的方法，将任务分解，分成小模块，感觉难度不大就 0.5 天，感觉比较复杂就 1 天，感觉非常复杂就继续划分模块，再将这些划分出的模块进行排期，用这种方式很容易就可以将任务拆解完，最后将每个模块的估期汇总，便可以得出整个项目需要的时间，联调的时间根据接口数量以及复杂度进行估算，最后再给自己两天 buffer 时间以防万一。</p>
<p>这样的方式使得项目排期变得不再无处下手，让整个流程清晰，不过对于开发的要求就相对严格，必须在规定的时间之前完成相关模块的开发，这就回到之前提到的，给自己一个合理的时间规划，并且严格执行。这应该是一个非常基础的习惯，但是之前没有养成，只能现在来补，亡羊补牢，为时未晚。</p>
<p>中午吃饭时，启蒙问我在公司的感觉如何，个人而言，对这家公司非常有好感，很幸运能加入，他鼓励我好好加油，说这段时间会是成长最快的时间，对此我深信不疑，这段时间我能感受到我的进步，接下来还有更多的挑战，希望通过这些挑战上升到一个新的境界，因此不能放松对自己的要求。面对未来，即紧张，又兴奋。</p>
<p>这段时间想清楚了一件事，技术没有非此即彼。没有最好，只有最合适。记得来公司面试，二面我问教主，为什么后台不统一用 JAVA 或者 PHP，前端没有统一使用框架，为什么不用 vue，而是用 react。现在看这个问题，大概因为一个人做项目做久了，太理想化，学校作业和实际项目工程差距很大。</p>
<p>学生时代，在项目里遇到很烂的代码，看不顺眼就想着重构，在百度实习期间也看过很多很烂的代码，但不敢碰，原因是因为不知道改了之后会出现什么问题，这就是问题关键所在，什么是好代码？什么又是烂代码？在生产环境中，首先需要确保的是项目的稳定性，保证项目的正常运行，所做的一切改动的前提都应该是项目的稳定运行。我时常吐槽烂代码都是以开发者的角度看问题，出于代码洁癖，并没有从项目的角度看待问题。从这个角度看，我可能是个好的编码者，但是不是一个合格的开发者，<strong>开发者应该以解决问题作为思考的方向，而不是为了编码而编码，只有编码者才会纠结编码方式，开发者只会考虑解决方案。</strong>但往往好的开发者都会养成好的编码方式。</p>
<p>前几天我在 less、sass、stylus 之间纠结，思考哪一个才是最佳的方案，最后发现这个问题本身就是个伪命题，因为作为一个合格的开发者，我应该三者都会，在处理问题的时候立刻上手解决问题，我可以选择一个作为个人偏好，语言之间没有最好，只有最合适，在需要的地方使用合适的语言，理解了这一点，顿时感觉视野开阔。</p>
<p>反思之前非此即彼的想法，实属懒惰的想法，学习好一门框架也好，构建工具也罢，难以掩盖的是我懒惰，不想学习新框架新工具的小心思。因此面对选择时，我会很自然的选择自己熟悉的框架或者工具，而不是出自于项目需要的考量。这样看来，我永远不可能成为一个好的开发者，</p>
<p>不因该局限一隅，哪有什么最优解，只有相对最合适的解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间：2017-7-27&lt;br&gt;坐标：北京&lt;br&gt;天气：阴&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="llog" scheme="http://lijundong.com/categories/llog/"/>
    
    
      <category term="llog" scheme="http://lijundong.com/tags/llog/"/>
    
  </entry>
  
  <entry>
    <title>网上高效阅读</title>
    <link href="http://lijundong.com/surf-the-Internet-efficiently/"/>
    <id>http://lijundong.com/surf-the-Internet-efficiently/</id>
    <published>2017-07-24T04:08:03.000Z</published>
    <updated>2017-07-24T06:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络信息多且繁杂，利用工具提高阅读效率，你如何过滤信息 ？你如何使用 Pocket 和 Evernote ？</p>
<a id="more"></a>
<h3 id="序言：现状"><a href="#序言：现状" class="headerlink" title="序言：现状"></a>序言：现状</h3><p>在<a href="http://www.lijundong.com/normalize-life-with-tools/" target="_blank" rel="external">「给生活一个规范」</a>一文里，我提到要给一个高频事件添加一个相对最优的方案，比如使用工具。<br>我日常会使用 Pocket 和各种笔记应用（Evernote、oneNote、有道云笔记等）保存看到的文章，只不过没有明确两种工具的使用场景，使用的方式混乱，没有形成规范，导致文章保存后打开率非常低，也没能形成有效的价值积累。今天来给一个目前认为最佳的解决方案。</p>
<h3 id="工具场景"><a href="#工具场景" class="headerlink" title="工具场景"></a>工具场景</h3><p>Pocket 和笔记类产品的应用场景完全不同，Pocket 的功能主打 Mark 功能，即标记，标记方便稍后阅读（read it later），标记的是文章的链接，如果文章链接失效了，这个标记也就无意义了。</p>
<p>以 Evernote 为代表的笔记应用主打笔记和剪藏的功能，即将文章内容复制到我的笔记账户中，这个副本记录的是内容，不再受原链接内容影响，完全独立，我们可以在原内容之上进行笔记、二次创作等。</p>
<h3 id="流程规范"><a href="#流程规范" class="headerlink" title="流程规范"></a>流程规范</h3><p>此规范来源于万维刚先生的<a href="https://book.douban.com/subject/25986341/" target="_blank" rel="external">「万万没想到：用理工科思维理解世界」</a>中的“高效冲浪的办法”一节。</p>
<h4 id="只点不看"><a href="#只点不看" class="headerlink" title="只点不看"></a>只点不看</h4><p>在浏览信息过程中，一篇文章或者是一个页面中会附有很多链接，推荐的方法是将遇到的新链接在新 Tab 中打开（PC 端按住 Ctrl/ Cmmand 点选链接），保证本页的阅读不被打断。只点链接不看。</p>
<h4 id="略读"><a href="#略读" class="headerlink" title="略读"></a>略读</h4><p>接下来速读每条信息，迅速过滤低质量信息，面对质量尚可的文章，使用 Chrome 的 Pocket 插件将链接添加到 Pocket 列表中。</p>
<h4 id="精读"><a href="#精读" class="headerlink" title="精读"></a>精读</h4><p>以两天或三天为一个周期，对 Pocket 中的精选文章精读，一旦发现文章质量好到了永久保存的程度，使用笔记应用的剪藏插件剪藏内容到笔记本中，方便后期处理。</p>
<h4 id="价值积累"><a href="#价值积累" class="headerlink" title="价值积累"></a>价值积累</h4><p>对剪藏的内容进行整理，归类，方便后期进行检索，同时可以在此文之上进行二次总结，进行笔记。</p>
<h3 id="跋"><a href="#跋" class="headerlink" title="跋"></a>跋</h3><p>使用宽框架过滤信息，可以保证信息的相对高质量。</p>
<blockquote>
<p>诺贝尔经济学奖得主丹尼尔·卡尼曼在《思考，快与慢》一书中介绍了两个著名的心理学概念：“窄框架”（narrow framing）和“宽框架”（broad framing）。所谓窄框架，就是遇到一个东西做一次决策，一事一议；而宽框架则是把所有东西都摆在桌面上集中选择。</p>
</blockquote>
<p>好的信息来源是好文章的保证，每一个好作家肯定都会有一个收集信息的体系，我一直想试图建立这样的体系，希望本文对你有益。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>万维钢(同人于野). 万万没想到:用理工科思维理解世界 (Kindle 位置 2312-2314). 电子工业出版社. Kindle 版本.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络信息多且繁杂，利用工具提高阅读效率，你如何过滤信息 ？你如何使用 Pocket 和 Evernote ？&lt;/p&gt;
    
    </summary>
    
      <category term="规范" scheme="http://lijundong.com/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="规范" scheme="http://lijundong.com/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="阅读" scheme="http://lijundong.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="pocket" scheme="http://lijundong.com/tags/pocket/"/>
    
      <category term="evernote" scheme="http://lijundong.com/tags/evernote/"/>
    
  </entry>
  
  <entry>
    <title>Charles 使用小记</title>
    <link href="http://lijundong.com/use-charles-up-to-debug/"/>
    <id>http://lijundong.com/use-charles-up-to-debug/</id>
    <published>2017-07-20T08:34:44.000Z</published>
    <updated>2017-07-24T07:24:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>脱离使用场景谈工具都是在扯淡，今天咱们不扯淡，说点有用的，最近做的一个项目中，使用了 Charles 让调试变得简单很多，这是可以提升编码幸福感的工具，这里总结几个常用的 feature。</p>
<a id="more"></a>
<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><p>电脑系统：MacOS 10.12.6<br>Charles 版本：4.1.4</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>当下的移动应用开发广泛应用了 Hybrid 模式，将 H5 页面嵌入原生应用中，以手机 QQ 为例，<a href="http://mp.weixin.qq.com/s/evzDnTsHrAr2b9jcevwBzA" target="_blank" rel="external">70% 以上业务是由 H5 开发</a>，由此可见一斑。<br>常规的开发流程是 FE 在本地开发环境中写好 H5 页面，开发完成后，后台 RD 将项目部署到测试版本中，手机下次测试版 APP，在 APP 内对页面进行测试。</p>
<p>FE 在开发环境中可以通过浏览器调试，部署到测试环境后，遇到新的 bug 或是需求的改动，需要在本地改动代码，重新部署到测试包，打开 APP 进行验证。这个过程太复杂，后台 RD 也会很烦。</p>
<p>这时候就需要 Charles 辅助开发。</p>
<h3 id="关于-Charles"><a href="#关于-Charles" class="headerlink" title="关于 Charles"></a>关于 Charles</h3><p>Charles 常用于截取网络封存包，可以设想一下，你的手机与服务器之间存在一个代理服务器，手机所有的请求都会经过这个代理服务器，如下示意图<br><img src="" alt=""><br>设想你是一个负责收发信件的信使，当一位客户将书信交予你递送时，你可以按常规流程去递送，也可以在非常规状态下更改信件的内容、收信人等，你还可以决定这封信递送的速度，甚至直接将这封信拦截不送，知道收信人地址的你，可以反复递送信件考研收件人的耐心。收信人的回信，你可以将其修改，调包。长此以往，作为信使，你可能会被投诉，开除。但作为工具，你可以成为 Charles，受到大批开发者的拥趸。</p>
<h3 id="监听设备"><a href="#监听设备" class="headerlink" title="监听设备"></a>监听设备</h3><p>为了 Charles 能监听到你的移动设备的所有请求，你需要做一点配置</p>
<ul>
<li>你的移动设备与电脑处于同一局域网下，查看你电脑在此局域网下的 IP</li>
<li>打开 Charles，Proxy &gt; MacOS proxy，在 Proxy setting 下设置监听端口，默认 8888</li>
<li>关闭移动端的所有代理工具，VPN、Shadowsocks 等</li>
<li>在移动设备 WLAN 设置中，添加代理，IP 和 端口分别时电脑的 IP 以及 Charles 设置的端口</li>
<li>退出 WLAN 设置，进入浏览器，访问网络，Charles 会显示设备连接请求，点击同意，可以看到在 session 窗口中迅速显示监听到的请求，配置结束。</li>
</ul>
<h3 id="常用-feature"><a href="#常用-feature" class="headerlink" title="常用 feature"></a>常用 feature</h3><p>前面都是介绍以及配置，下面介绍几个常用的 feature。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>点选 session 窗口中的请求，右键查看选项，选项的最后两项即是 map 选项，提供了 <code>map remote/map local</code> 选项，可以将请求的资源映射到本地或者远程的资源，举个例子。<br>你需要调试页面中的 JS 代码，你可以将页面的 JS 请求映射到本地开发环境中的 JS 文件，刷新页面后，页面请求到的是本地 JS 文件，如此一来，修改本地 JS 后，刷新页面就可以在 APP 内查看到效果。<br>map 是这次开发中主要使用的功能，大幅度提高了我的开发效率。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="external">Charles 从入门到精通</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;脱离使用场景谈工具都是在扯淡，今天咱们不扯淡，说点有用的，最近做的一个项目中，使用了 Charles 让调试变得简单很多，这是可以提升编码幸福感的工具，这里总结几个常用的 feature。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="http://lijundong.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="hybrid" scheme="http://lijundong.com/tags/hybrid/"/>
    
      <category term="debug" scheme="http://lijundong.com/tags/debug/"/>
    
      <category term="charles" scheme="http://lijundong.com/tags/charles/"/>
    
  </entry>
  
  <entry>
    <title>用户体验之 localStorage</title>
    <link href="http://lijundong.com/improve-UE-by-localStorage/"/>
    <id>http://lijundong.com/improve-UE-by-localStorage/</id>
    <published>2017-07-05T12:10:38.000Z</published>
    <updated>2017-07-06T10:11:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过在页面应用使用 localStorage 提升用户使用体验。 </p>
<a id="more"></a>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>首先，来说两个关于用户体验的经历。<br>大学在校期间，经常被安排在教学系统上填写各种信息采集表，教学系统是学校找外面外包公司做的，给的钱多，出的活却很烂，信息采集的表单是很老旧的 table 布局，一页一个表单，一个表单有几十个项，当你辛辛苦苦填完了整个表单，点击提交按钮页面却没有响应，系统卡了？你抱着试一试的心态刷新了页面，恭喜你，之前填的数据全部丢失，像是卷入了一个黑洞，你又从第一项开始填。这样的系统毫无用户体验可言，不是强制要求，没人愿意打开这样的网站。<br>到了大三找实习，投简历到阿里，需要在系统上填一些信息，对应的也是一个表单很多项，巧的是，提交时页面卡住了，虽然脑海中重现了被学校系统支配的恐惧，但除了刷新页面别无选择，刷新之后，页面回来了，之前填写的数据竟然原封不动的回来了，当时很菜，不知道是怎么实现，就觉得背后的技术肯定很厉害，后面才去了解这方面的知识。<br>后来了解了 localStorage 之后，才意识到表单数据保存背后的技术很简单，但是用在了相应的场景，给用户带来的是非常棒的用户体验，从那之后，我对阿里校招页面一直很有好感。</p>
<h3 id="关于-localStorage"><a href="#关于-localStorage" class="headerlink" title="关于 localStorage"></a>关于 localStorage</h3><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>localStorage 的容量是相对其作用域而言，而 localStorage 的作用域是 <code>协议 + 主机名 + 端口</code>，目前业界默认同一作用域下拥有 5M 的容量，手机端和 PC 端标准略有不同。<br>数据以键值对方式存储，同一作用域下的数据可以被相互访问，并且不允许跨域。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">"name"</span>,<span class="string">"leeon"</span>);	<span class="comment">//设置 name 值 为 leeon</span></span><br><span class="line">localStorage.getItem(<span class="string">"name"</span>);	<span class="comment">//获取 name 的值</span></span><br><span class="line">localStorage.key(<span class="number">0</span>); 	<span class="comment">//获取第 0 个数据项的 key 名</span></span><br><span class="line">localStorage.removeItem(<span class="string">"name"</span>);	<span class="comment">//移除 name 对应的键值对</span></span><br><span class="line">localStorage.clear();	<span class="comment">//清除当前作用域下的所有localstorage数据</span></span><br></pre></td></tr></table></figure>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>上面提到的表单数据保存是最常见的场景，避免信息的丢失，实现方式是在 <code>input</code> 标签 <code>blur</code>（失焦) 后，触发 localStorage 存储，页面加载之后，从 localStorage 读取已存储的数据，表单提交成功后，移除存储的数据。</p>
<p>还有一种情况，类似于博客系统内置的评论功能，页面可以参见下图，这样的场景，没有登陆，用户信息不能持久化保存，每次评论都需要再次填写基础信息<br><img src="http://source.lijundong.com/17-7-6/47641822.jpg" alt=""></p>
<p>应用 localStorage 保存用户基础信息，我用 React 写了一个评论框输入组件，包含的 <code>_saveUsername</code> 和 <code>_loadUsername</code> 方法对应着用户信息的存储以及获取，分别会在输入框失焦以及页面渲染时被调用，体验更好的方式则是提供一个保存基本信息的选项，用户在勾选后，信息被保存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentInput</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            username: <span class="string">''</span>,</span><br><span class="line">            content: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> PropType = &#123;</span><br><span class="line">        onSubmit: PropType.func</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>.textarea.focus()</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">        <span class="keyword">this</span>._loadUsername()</span><br><span class="line">    &#125;</span><br><span class="line">    _saveUsername (username) &#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'username'</span>, username)</span><br><span class="line">    &#125;</span><br><span class="line">    _loadUsername () &#123;</span><br><span class="line">        <span class="keyword">const</span> username = localStorage.getItem(<span class="string">'username'</span>)</span><br><span class="line">        <span class="keyword">if</span>(username) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;username&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleUserNameBlur (event) &#123;</span><br><span class="line">        <span class="keyword">this</span>._saveUsername(event.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">    handleUsernameChange (event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            username: event.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    handleContentChange (event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            content: event.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    handleSubmit () &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.props.onSubmit) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;username, content&#125; = <span class="keyword">this</span>.state</span><br><span class="line">            <span class="keyword">this</span>.props.onSubmit(&#123;</span><br><span class="line">                username: <span class="keyword">this</span>.state.username, </span><br><span class="line">                content: <span class="keyword">this</span>.state.content,</span><br><span class="line">                createdTime: +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;content: <span class="string">''</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment-input"</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment-field"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"comment-field-name"</span>&gt;</span>userName:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment-field-input"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span></span><br><span class="line">                        <span class="attr">onBlur</span>=<span class="string">&#123;this.handleUserNameBlur.bind(this)&#125;</span></span><br><span class="line">                        <span class="attr">value</span>=<span class="string">&#123;this.state.username&#125;</span></span><br><span class="line">                        <span class="attr">onChange</span>=<span class="string">&#123;this.handleUsernameChange.bind(this)&#125;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment-field"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"comment-field-name"</span>&gt;</span>Comment:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment-field-input"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">textarea</span></span><br><span class="line">                        <span class="attr">ref</span>=<span class="string">&#123;(textarea)</span> =&gt;</span> &#123;this.textarea = textarea&#125;&#125;</span><br><span class="line">                         value=&#123;this.state.content&#125; </span><br><span class="line">                         onChange=&#123;this.handleContentChange.bind(this)&#125;</span><br><span class="line">                        &gt;<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"comment-field-button"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleSubmit.bind(this)&#125;</span> &gt;</span>comment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="关于用户体验"><a href="#关于用户体验" class="headerlink" title="关于用户体验"></a>关于用户体验</h3><p>因为做的工作的原因，遇到一些很棒的网站第一反应是打开控制台看代码，每每看到那些巧妙的代码都赞叹不已，少量的代码带来用户体验的大幅度提升，这是具有很高性价比的一件事。遇到一些烂糟糟的设计，会考虑烂的原因，以及如何去改进，比如渣浪的微博。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过在页面应用使用 localStorage 提升用户使用体验。 &lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://lijundong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="UE" scheme="http://lijundong.com/tags/UE/"/>
    
      <category term="localstorage" scheme="http://lijundong.com/tags/localstorage/"/>
    
  </entry>
  
  <entry>
    <title>给生活一个规范</title>
    <link href="http://lijundong.com/normalize-life-with-tools/"/>
    <id>http://lijundong.com/normalize-life-with-tools/</id>
    <published>2017-06-29T12:03:35.000Z</published>
    <updated>2017-06-29T12:06:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>生活中的高频问题都应有一个相对最优解，如果没有，你应该有一个。</p>
<a id="more"></a>
<p>生活中有很多易用并能极大提高效率的工具，借助这些工具，可以让过程事半功倍，我喜欢搜寻可以解决生活痛点的工具，搜寻到的工具，有些成了生活工作必不可缺的一部分，有些，则只是好工具，我并没有高频使用，主要原因是因为在生活与工作时，没能形成一个体系，没有一个成型的规则。</p>
<p>做事没有规则的结果，就是在多次处理同一问题时，可能会选择多种解决方式，每次选了新的解决方式都可能会出现新的问题，无形中增加了处理成本，再者，每次解决问题后，都会获得已知的相对最优解，再次遇到相同问题时，抛弃最优解的处理方式无疑是对之前投入成本的浪费，长此以往，就陷入了高投入低产出的低效局面。</p>
<p>我一直想解决这个问题，试图给遇到的高频问题一个普世方案，在处理问题时高效果断，例如最基本 GTD（get things done），市面上存在的优秀的 GTD 工具已经非常多了，我试过很多款，都是拥有庞大用户基数的工具，体验很棒，然而具体也只是试用而已，我一直没能生成一个 GTD 规范，待处理事项仍旧依靠大脑缓存，处于这样的状态，一是我待处理的事物数量不大，大脑可以应付，这种状态的改变不是必须，二是我没有提高效率的意识。这样的状态虽然很少出错，但是有弊端，我需要通过高频率的回忆来加深记忆，这样回忆的过程可能发生在任何时候，在我工作之余放松的时候，在我专注思考问题的时候，这个提醒会突然蹦出来打断我，这种隐形成本的消耗是巨大的。另一个例子是关于写博客，我用 sublime 或者 vim（比如这篇）编写 markdown，通过 hexo 将生成的文件推到服务器，偶尔一篇文章会在多个平台发布，我需要在每个站点贴一遍，中间消耗的成本可以看得见。还有一个例子，我这个人不善交际，情商很低，在大街上遇到同一个人（认识但不熟），我可能一次会选择热情打招呼，另一次，选择装作没看见，是不是很奇葩？我自己也觉得奇葩，这样的结果就是我与那些人形同陌路。在遇到一些二选一的情况时，我没有一个完整的规则体系，最后的结果往往带来很多苦恼。以上三个问题只是一部分，但已经说明了很多问题。</p>
<p>我今天在用 google calendar 制定日程，未来的一段时间里，它应该会被高频使用，iOS 原生的提醒也开始用，需要查看待处理事项时，大脑告诉我打开工具去看，不需要高频率的让大脑高频 check 事项。生活中还有很多低效的地方，我意识到的以及没能意识到的，都待被改进。</p>
<p>两年前开始折腾 shadowsocks，之后开始用 Chrome 和 Google 账户，从那之后就很少使用国内的搜索引擎，我的设备上再也没出现国内的浏览器，这就是我的规则，这些工具和模式已经成为默认选项，一个稳态，即便环境变化，经过调整后，又进入另一个稳态，这就是我想达到的效果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生活中的高频问题都应有一个相对最优解，如果没有，你应该有一个。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://lijundong.com/categories/life/"/>
    
    
      <category term="life" scheme="http://lijundong.com/tags/life/"/>
    
      <category term="规范" scheme="http://lijundong.com/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 下合并不同 Google 账号数据</title>
    <link href="http://lijundong.com/synchronize-data-between-google-accounts/"/>
    <id>http://lijundong.com/synchronize-data-between-google-accounts/</id>
    <published>2017-03-16T10:34:11.000Z</published>
    <updated>2017-03-17T02:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果你在 Chrome 上同时拥有了两个 Google 账号，并深受其扰，开始想着合并两个账户的数据到某一个账户，我想告诉你，这真的远比想象的简单。</p>
<a id="more"></a>
<p>在今天之前一直使用的是两个 google 账号，主要的数据在于 Chrome 上存储的扩展、书签以及密码，新号用于邮件管理，两个账号的使用随着时间的延续会让事情变得复杂，之前没找到合适的方式，今天在官方的帮助文档里找到了解决方案：</p>
<blockquote>
<ol>
<li>打开 Chrome。</li>
<li>点击右上角的“更多”图标 更多。</li>
<li>点击设置。</li>
<li>在“登录”下方，点击取消与您的 Google 帐户的关联。</li>
<li>点击断开帐户连接。</li>
<li><strong>提示是否保留数据，选择保留</strong></li>
<li>点击登录 Chrome。</li>
<li>使用新账户进行登陆</li>
<li><strong>提示是否同步数据，选择同步</strong></li>
</ol>
</blockquote>
<p>Alphabet 的产品才是真的感动人心。</p>
<p>来源：<a href="https://support.google.com/chrome/answer/6386684?hl=zh-Hans" target="_blank" rel="external">在 Chrome 中切换同步帐户</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你在 Chrome 上同时拥有了两个 Google 账号，并深受其扰，开始想着合并两个账户的数据到某一个账户，我想告诉你，这真的远比想象的简单。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="http://lijundong.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="google" scheme="http://lijundong.com/tags/google/"/>
    
      <category term="数据" scheme="http://lijundong.com/tags/%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 的赋值、引用以及深拷贝、浅拷贝</title>
    <link href="http://lijundong.com/deep-clone-vs-shallow-clone/"/>
    <id>http://lijundong.com/deep-clone-vs-shallow-clone/</id>
    <published>2017-02-27T13:04:43.000Z</published>
    <updated>2017-02-28T16:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前总结 <a href="http://www.lijundong.com/this-in-javascript/" target="_blank" rel="external">This 用法</a> 的时候,遇到了传参问题，由此意识到了复制与引用的问题，说得高端些，引申出了深拷贝与浅拷贝的问题，后来在链家面试的时候，和一面也讨论到这个问题，当时的理解比较乱，涉及到深拷贝实现的方面都不熟悉，现在试着总结一下。</p>
<a id="more"></a>
<h3 id="基本类型-amp-引用类型"><a href="#基本类型-amp-引用类型" class="headerlink" title="基本类型 &amp; 引用类型"></a>基本类型 &amp; 引用类型</h3><p>ECMAScript 中的变量类型分为两类</p>
<ul>
<li>基本类型：number、string、boolean、null、undefined</li>
<li>引用类型：Object</li>
</ul>
<p>两者的区别就是这篇文章要讨论的赋值问题，首先复习一下两种变量类型的存储方式。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型变量的存储方式如下图所示，栈内存中分别存储着变量的标识符以及变量的值。</p>
<p><img src="http://source.lijundong.com/17-2-28/11497418-file_1488289350451_141ba.png" alt=""></p>
<p>所以 <code>var a = &#39;leeon&#39;;</code> 这里的 a 就是以下面的的方式进行存储。</p>
<p><img src="http://source.lijundong.com/17-2-28/17191622-file_1488289392814_648.png" alt=""></p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>至于引用类型变量，参看下图，可以对比上面基本类型变量的存储结构。</p>
<p><img src="http://source.lijundong.com/17-2-28/579494-file_1488289373542_128ea.png" alt=""></p>
<p>引用类型变量与基本类型变量的区别是，栈内存存储的是变量的标识符以及对象在堆中的存储地址。可能听起来拗口，例如 <code>var obj1 = {name: &#39;leeon&#39;};</code> 这样的对象定义之后，就会以下图的方式进行存储。</p>
<p><img src="http://source.lijundong.com/17-2-28/28695556-file_1488289419385_10e6a.png" alt=""></p>
<p>存储结构的差异只是前提，下面的代码才到重点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情境一</span></span><br><span class="line"><span class="comment">// 基本类型变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'leeon'</span>;  <span class="comment">//leeon</span></span><br><span class="line"><span class="keyword">var</span> b = a;       </span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//leeon</span></span><br><span class="line">b = <span class="string">'pine'</span>;      <span class="comment">// pine</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//leeon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码很简单，改变 b 并不会影响到 a</span></span><br><span class="line"><span class="comment">// 下面这段就不同了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情境二</span></span><br><span class="line"><span class="comment">//引用类型变量</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;name: <span class="string">'leeon'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(obj2);  <span class="comment">// &#123;name: 'leeon'&#125;</span></span><br><span class="line">obj2.name = <span class="string">'pine'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1);  <span class="comment">// &#123;name: 'pine'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj2 是 obj1 的副本，但修改 obj2 却影响了 obj1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情境三</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;name: <span class="string">'leeon'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(obj2);  <span class="comment">// &#123;name: 'leeon'&#125;</span></span><br><span class="line">obj2 = &#123;name: <span class="string">'pine'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1);  <span class="comment">// &#123;name: 'leeon'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj2 是 obj1 的副本，但修改 obj2 没有影响了</span></span><br></pre></td></tr></table></figure>
<p>这样的问题最初遇到时觉得很费解，但是从内存角度进行理解之后，答案开始清晰，情境一中，基本类型变量的拷贝，复制了变量的标识符以及值，<code>a</code> 与 <code>b</code> 的关系保持了独立。</p>
<p><img src="http://source.lijundong.com/17-2-28/62092344-file_1488289444123_a40c.png" alt=""></p>
<p>而在情境二中，在引用类型变量这里，拷贝时复制的是变量的标识符与 <strong>对象存储地址</strong>，导致最后 <code>obj1</code> 和 <code>obj2</code> 都指向同一个对象，<code>obj2</code> 和 <code>obj1</code> 只是同一对象的两个面具，相互影响自然是必然的结果。 </p>
<p><img src="http://source.lijundong.com/17-3-1/23876944-file_1488298747142_8a89.png" alt=""></p>
<p>但是情境三中，对 <code>obj2</code> 的更改却没影响到 <code>obj1</code>，这又是为什么？难道上面的理论有问题？当然不是，给 <code>obj2</code> 赋值一个新的对象，背后做的其实是将 <code>obj2</code> 的对象地址指向 <code>{name: &#39;pine&#39;}</code>，并不会影响到原对象，原理如下 ：<br><img src="http://source.lijundong.com/17-3-1/33543805-file_1488298796532_150c9.png" alt=""></p>
<p>这样的拷贝方式就引发了一个问题，我本想拷贝一个新的完全独立的新对象，最后只得出来一个壳，这是无法接受的（感受到了敷衍……）。这里就引出了深拷贝与浅拷贝之说（人们总喜欢造一堆高大上的概念）。</p>
<h3 id="深拷贝-amp-浅拷贝"><a href="#深拷贝-amp-浅拷贝" class="headerlink" title="深拷贝 &amp; 浅拷贝"></a>深拷贝 &amp; 浅拷贝</h3><p>由此可以明白，所谓浅拷贝，指的是仅拷贝对象地址，拷贝后的副本与原对象仍共用一块内存，而深拷贝则是将对象进行内存级别的复制，拷贝的副本与原对象保持独立。</p>
<h3 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="headerlink" title="如何实现深拷贝"></a>如何实现深拷贝</h3><h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oobj1 = &#123;name: <span class="string">'leeon'</span>,friens: &#123;name:[<span class="string">'john'</span>,<span class="string">'kk'</span>,<span class="string">'jd'</span>]&#125;&#125;;</span><br><span class="line">temp = <span class="built_in">JSON</span>.stringify(obj1);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(temp);</span><br><span class="line"><span class="comment">// p 是 o 的深拷贝</span></span><br></pre></td></tr></table></figure>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=arr1.slice(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// arr2 是 arr1 的深拷贝</span></span><br></pre></td></tr></table></figure>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.concat();</span><br><span class="line"><span class="comment">// arr2 是 arr1 的深拷贝</span></span><br></pre></td></tr></table></figure>
<h4 id="jQuery-的-extend"><a href="#jQuery-的-extend" class="headerlink" title="jQuery 的 extend()"></a>jQuery 的 extend()</h4><p><em>参考：</em></p>
<ul>
<li>(美)David Flanagan. JavaScript权威指南（原书第6版） (Kindle 位置 3112-3125).</li>
<li><a href="http://www.cnblogs.com/tracylin/p/5346314.html" target="_blank" rel="external">也来谈一谈js的浅复制和深复制</a></li>
<li>​<a href="http://bosn.me/js/js-call-by-sharing/" target="_blank" rel="external">JS是按值传递还是按引用传递?</a></li>
<li><a href="https://segmentfault.com/a/1190000002789651" target="_blank" rel="external">JS 进阶基本类型 引用类型 简单赋值 对象引用</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前总结 &lt;a href=&quot;http://www.lijundong.com/this-in-javascript/&quot;&gt;This 用法&lt;/a&gt; 的时候,遇到了传参问题，由此意识到了复制与引用的问题，说得高端些，引申出了深拷贝与浅拷贝的问题，后来在链家面试的时候，和一面也讨论到这个问题，当时的理解比较乱，涉及到深拷贝实现的方面都不熟悉，现在试着总结一下。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://lijundong.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://lijundong.com/tags/javascript/"/>
    
      <category term="深拷贝" scheme="http://lijundong.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
      <category term="浅拷贝" scheme="http://lijundong.com/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>早班车乱谈</title>
    <link href="http://lijundong.com/think-in-early-bus/"/>
    <id>http://lijundong.com/think-in-early-bus/</id>
    <published>2017-02-17T01:34:10.000Z</published>
    <updated>2017-06-26T12:59:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们处在一个巨大的变革之中。</p>
<a id="more"></a>
<p>最近在看 「天才在左，疯子在右」，没看之前一直以为是描述疯狂的天才，看了才知道是一本精神病患者访谈录，每篇文章，作者记录和一位患者的交流过程，书中每一个病例，没有病因，没有结论，作者只是在记录这些奇怪的病例以及现象。这让我想起了初中看的「故事会」里面描述的鬼怪之说，所以书中内容我已经不关心，继续看是因为某些患者的想法十分有趣，每看完一篇，我甚至都会想好一会，我可能是下一位患者。</p>
<p>这就是早班车乱谈的来由，坐上公司的班车，我开始胡思乱想。</p>
<p>老司机！开车啊</p>
<p>现在看来，「Matrix」真是一部具有超时代意义的电影，十年前看的时候，我只单纯地把它作为科幻电影对待，但如今再看，愈发觉得这会是个预言，科技的发展不断把我们向前推，那个 matrix 世界的轮廓也愈加的明显。</p>
<p>谁也无法保证我们不是生活在一个 matrix 世界里，活着的感觉也许只是脑电波的闪动，我们连躯体都不需要，只需要思考的脑体，连上主机。那么，存在的意义在哪 ？</p>
<p>VR 的技术日臻成熟，不消几年，VR 会和智能手机一样普及，VR 欺骗了我们的眼睛，那么，VR 之后呢？直接欺骗我们的神经系统如何 ？技术足够成熟，给大脑接一根数据线，我们获得了与现实一样的感受，在那里，你长得帅，娶了一位漂亮的姑娘，生活没有烦恼，没有顾虑，你还愿意回来吗？那些生活痛苦的人，现实生活不如意的人，选择了把自己托管到主机上，只需要低成本就可以开始一段多彩缤纷的生活。最后的结果会不会是 matrix ？</p>
<p>我们坐上了一趟停不下来的火车，不知道下一个隧道之后是美景还是深渊。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们处在一个巨大的变革之中。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://lijundong.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="matrix" scheme="http://lijundong.com/tags/matrix/"/>
    
      <category term="早班车" scheme="http://lijundong.com/tags/%E6%97%A9%E7%8F%AD%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Mac 备份方案</title>
    <link href="http://lijundong.com/backup-in-mac/"/>
    <id>http://lijundong.com/backup-in-mac/</id>
    <published>2017-02-14T09:23:36.000Z</published>
    <updated>2017-02-14T06:54:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>行走江湖，讲求的是一个稳字。</p>
<a id="more"></a>
<p>在狗东买的硬盘下午到了，折腾了下，格式化、分区、备份。这里记录下我的方案。</p>
<h3 id="关于硬盘"><a href="#关于硬盘" class="headerlink" title="关于硬盘"></a>关于硬盘</h3><p>硬盘、耳机一类带有玄学色彩的电子产品，我选购的经验是预算之内跟着群众走，排除你有情怀或者是行家里手的情况。作为普通消费者，我们的需求也很简单，因此不必考虑那些极端环境,只要不犯错就达到我们的基本诉求了，毕竟群众的眼睛是雪亮的。<br>所以，我买了希捷的 <a href="http://detail.zol.com.cn/move_disk/index364131.shtml" target="_blank" rel="external">Backup-Plus-Slim-1TB(STDR1000300)</a>。</p>
<p>我是跟着群众走的，所以不要问我为什么……</p>
<h3 id="关于用途"><a href="#关于用途" class="headerlink" title="关于用途"></a>关于用途</h3><p>我买的容量是 1T，计划分区出 250G 作为 timeMachine 的备份空间 A，剩下的用做日常文件存储 B。</p>
<h3 id="关于文件格式"><a href="#关于文件格式" class="headerlink" title="关于文件格式"></a>关于文件格式</h3><p>先抛出结论，硬盘分为两个区，250G 备份分区 A 格式化为 <code>Mac OS Extended</code> 格式，另一分区 B 格式化为 <code>exfat</code> 格式，将硬盘转插在 windows 上，将 B 分区格式化为 <code>NTFS</code> 文件格式。</p>
<p>为适配 Windows，故将大分区 B 设置成 <code>NTFS</code> 格式，<code>NTFS</code> 在 Mac 下可读不可写，但是希捷官方提供了适用于 MacOS(10.9. 及以上)的 <a href="http://www.seagate.com/cn/zh/support/downloads/item/ntfs-driver-for-mac-os-master-dl/" target="_blank" rel="external">Paragon</a>，所以唯一的问题也被解决了。</p>
<h3 id="timeMachine"><a href="#timeMachine" class="headerlink" title="timeMachine"></a>timeMachine</h3><p>关于 timeMachine 的使用，极其简单，打开 timeMachine，选择备份盘，备份。</p>
<p><strong>建议每次升级之前先备份一次。</strong></p>
<h3 id="关于恢复"><a href="#关于恢复" class="headerlink" title="关于恢复"></a>关于恢复</h3><p>目前我还没用到恢复，希望永远也用不到，哈哈。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行走江湖，讲求的是一个稳字。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="http://lijundong.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="备份" scheme="http://lijundong.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
      <category term="timemachine" scheme="http://lijundong.com/tags/timemachine/"/>
    
      <category term="mac" scheme="http://lijundong.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 中 this 的指向</title>
    <link href="http://lijundong.com/this-in-javascript/"/>
    <id>http://lijundong.com/this-in-javascript/</id>
    <published>2017-02-13T11:11:50.000Z</published>
    <updated>2017-02-13T18:19:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 javascript 中 this 用法的笔记，来自 <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch1.md" target="_blank" rel="external">You Don’t Know JS: this &amp; Object Prototypes</a> 的读书笔记。内容包括 this 绑定规则的总结，以及遇到具体问题时，判断 this 指向的方法。</p>
<a id="more"></a>
<p>首先了解下 this 的绑定规则，分别是 <code>默认绑定</code>、<code>显式绑定</code>、<code>隐式绑定</code>、<code>new 绑定</code>，说是绑定规则，我的理解是四种应用场景，不同的应用场景对应着不同的指向。</p>
<h3 id="指向规则"><a href="#指向规则" class="headerlink" title="指向规则"></a>指向规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>默认绑定的方式很常见，举个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">fun(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>在默认绑定规则下，<strong>this 被绑定到了全局对象</strong>，所以例子中输出的 <code>this.a</code> 的值即全局变量 <code>a</code> 的值。</p>
<p>需要注意的是，绑定到全局对象只存在于非严格模式下，当使用严格模式时，<strong>this 会被绑定到 undefined</strong>。参见下面的案例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">fun(); <span class="comment">// this is undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>相比于默认绑定只有两个选项，隐式绑定就含蓄的多，我们需要分析上下文来弄清 this 的指向。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: fun</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>foo 作为引用属性被调用，虽然 foo 不属于 obj 对象，但在被调用时，foo 落脚于 obj 对象，<strong>隐式绑定将 this 绑定到此时的上下文对象</strong>，所以 此时的 <code>this.a</code> 和 <code>obj.a</code> 是一样的。</p>
<p>这一个例子还不能完全将隐式绑定解释清晰，为此，我们需要更多的例子,下面我们来讨论下引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  foo: fun</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  obj: obj1</span><br><span class="line">&#125;;</span><br><span class="line">obj1.foo(); <span class="comment">//1</span></span><br><span class="line">obj2.obj.foo(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>如果遇到这样的引用链，稍加分析不难理解，对象属性引用链中只有最顶层或者说最后一层会影响 this 的上下文，换而言之，在分析引用链中的 this 指向，只需要分析最后一层即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  foo: fun</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line">bar(); <span class="comment">//global</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>bar</code> 引用 <code>obj.foo</code>，<code>obj.foo</code> 引用 <code>fun</code>，归根结底，<code>bar</code> 引用的还是 <code>fun</code>，最后在调用时，和 <code>obj</code> 并没有关系，这只是开始，下面继续。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doDoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  foo: fun</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line">doFoo(obj.foo); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>这段代码中的参数传递其实就是一种隐式传值，看到这里有没有觉得似曾相识，跟上一段代码异曲同工，表面上调用的是 <code>obj.foo</code> 其实与 <code>obj</code> 并无联系。<code>doFoo()</code> 中执行的 <code>foo()</code> 调用的是 <code>fun()</code>。趁热打铁，再来一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  foo: fun</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line">setTimeout(obj.foo, <span class="number">1000</span>); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>这段代码和上一段并无二致，只不过这种情形在开发中经常会遇到，this 丢失问题，有没有好办法，肯定有，往下看。</p>
<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>显式绑定通过 <code>call(…)</code>、<code>apply(…)</code> 方法强制绑定 this</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  foo: fun</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line">obj1.foo(); <span class="comment">//1</span></span><br><span class="line">obj1.foo.call(obj2); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><code>call(…)</code> 方法将本来指向 <code>obj1</code> 上下文对象的 this 绑定到了 <code>obj2</code>，光明正大的挖墙脚……</p>
<p>为了解决之前的 this 丢失问题，在显式绑定的基础上升级出了<strong>硬绑定</strong>，此招一出，墙脚硬到磕坏牙，再也不用担心 this 会丢失了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  fun.call(obj);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'global'</span>;</span><br><span class="line">bar();  <span class="comment">// 2</span></span><br><span class="line">setTime(bar, <span class="number">1000</span>);  <span class="comment">//2</span></span><br><span class="line">bar.call(<span class="built_in">window</span>);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>看到没，稳如泰山。硬绑定在 ES5 之后有了现成可用的方法 <code>Function.prototype.bind</code>，其中一种应用场景如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">something</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something ); </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = fun.bind( obj );   </span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> );  <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>考虑下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> fun(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>使用 new 来调用 <code>fun(..)</code> 时，会构造一个新对象并把它绑定到 <code>fun(..)</code> 调用中的 this<br>上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p>
<p>New 绑定也是四种绑定中优先级最高的一种，连硬绑定也能掰弯</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = fun.bind(obj);</span><br><span class="line">bar(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);  <span class="comment">//  2</span></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a);  <span class="comment">//  2</span></span><br><span class="line"><span class="built_in">console</span>.log(baz.a);  <span class="comment">//  3</span></span><br></pre></td></tr></table></figure>
<p>在 new 对象时，预期 <code>obj.a</code> 值应该赋为 3，结果并没有修改，而是 new 出来一个新的对象，说明在 new 的过程中，this 的指向改变了。</p>
<h3 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h3><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><p>四种规则优先级先后顺序为： <code>new 绑定 &gt; 显式绑定 &gt;  隐式绑定 &gt; 默认绑定</code>。</p>
<p>根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断:</p>
<ol>
<li><p>函数是否在new中调用 ? 如果是的话this绑定的是新创建的对象。</p>
<p><code>var bar = new fun();</code></p>
</li>
<li><p>函数是否通过call、apply或者硬绑定调用 ? 如果是的话，this绑定的是 指定的对象。<br>  <code>var bar = fun.call(obj);</code></p>
</li>
<li><p>函数是否在某个上下文对象中调用 ? 如果是的话，this 绑定的是那个上 下文对象。<br> <code>var bar = obj.foo();</code></p>
</li>
<li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。<br> <code>var bar = fun();</code></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 javascript 中 this 用法的笔记，来自 &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/ch1.md&quot;&gt;You Don’t Know JS: this &amp;amp; Object Prototypes&lt;/a&gt; 的读书笔记。内容包括 this 绑定规则的总结，以及遇到具体问题时，判断 this 指向的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://lijundong.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="http://lijundong.com/tags/javascript/"/>
    
      <category term="this" scheme="http://lijundong.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>关于学习的反思</title>
    <link href="http://lijundong.com/think-about-learning/"/>
    <id>http://lijundong.com/think-about-learning/</id>
    <published>2017-02-10T07:48:11.000Z</published>
    <updated>2017-02-12T06:38:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>请告诉我，你的想法 ？</p>
<a id="more"></a>
<p>年初到现在看了几本书，从原理层面重新理解很多知识点，效果胜过之前看过的任何一篇 Blog。有所感，初拟的题目是「关于技术学习的思考」，后觉不妥，这样的反思不应止于技术。</p>
<p>进入大学之前，所有人都告诉我“你该考个好大学”，包括我自己，但是没人给出理由，同样包括我自己，我年复一年的准备就是为了那场考试，通过考试，进了大学，但从那之后，之前鼓励我考大学的人再没告诉我下一步该怎么走，如果你去问他们，他们不奢望你拿奖学金，但可能会鼓励你去考研，不可否认，“努力学习，拿高绩点，考研去一个更好的学校”，就是我进大学时对于四年的“规划”，美其名曰“规划”，我并不知道考研时为了什么，也不知道考研之后的日子该做什么，没课的时间就去图书馆自习做题，准时睡觉起床，偶尔去跑步，我只是换了一个环境继续着高中的生活，身后被一只无形的手推着走，终日处于一种被动无意识状态。</p>
<p>也许是生活太过枯燥，正好碰到学校的 ACM，于是开始刷题的日子，渐渐乐在其中，听前辈讲题，逛 CSDN，看别人的解题代码，也不求甚解，只浮于看到 Accept 的快感，就这样混了一年。因为选择进入机器人小组，结束了刷题的生活。小组的唯一任务就是准备每年的 Robocon，比赛强迫成员必须尽快的产出，因为对硬件一窍不通，遇到问题总是先去找现成的代码，整日地逛论坛，免费的论坛找不到，就和黄彪凑了 60 大洋买了 amoBBS 的会员，继续找，在网上找单片机视频教程，对着电脑看到昏睡，醒来继续看，仍是不求甚解，因为负责的视觉模块始终无进展，选择退出小组。后来接触 web，跟着 w3cSchool 的教程，又开始了自 high，看了一个月的教程，仍停留在写单页的水平，跟着粉丝日志做 express 开发，跟着 imooc 的视频做微信开发，不求甚解，遇到问题就去找答案，找到能用的答案，能用就行，不求甚解。似乎回到了为了 Accept 整日刷题的状态，我整日都在编码，但技术始终不得精进，终于有一天意识到一个很残酷的事实，我做的只是复制粘贴，一只都是原地踏步，忙碌的只是表象，只是一种主动的无意识状态而已。</p>
<p>我时常在想，一个优秀的工程师，应该像艺术家般，在代码中加入自己的思想，而现在的我仍只是在临摹，距离创作还有遥远的距离，但那是我的追求。BBS、Blog 存在的意义，更偏向经验的传播，在我需要时告诉我 How，但是夜深人静时，艺术家的梦再次扣上心扉，我想去追寻 What 和 Why 时，要探究技术的本质时，还是要去书中寻找。</p>
<p>知识付费在去年开始兴起，以值乎和分答为代表的付费问答，以得到为代表的付费订阅，随后兴起了付费社群。知识付费无疑空前利好创作者，他们可以生活的更好，这也是我希望看到的。不过对于其中的产品，用户还是要有准确的定位。<br>我有过一段时间很喜欢李笑来的观点，包括他的 「把时间当作朋友」，甚至把很多观点奉为圭臬，当时看的时候觉得干货满满，他是我了解的最先做付费社群的人，价格也很贵，崇尚终生学习，并名其新生大学，我一度想过存钱，加入那个社群，后来因为没存到钱（😂），不了了之，偶尔可以看到社群中的文章分享，觉得文风和「时间」一个味道，再读「时间」，不仅没了当初的激动之感，反而感觉到了浓浓的鸡汤风。后来看到他的知乎 live、学费数万元的全栈培训，也就释然了。相比于做比特币投资，我相信他更适合职业割韭菜。</p>
<p>我以技术学习的名义加入过很多技术交流群，结果是接下来的日子，因为群消息太吵我把这些群一个个地屏蔽了，我几乎没在群里说过话，也不怎么看消息，群里面讨论的话题太杂乱，群友水平参差不齐，交流效率奇差。我的初衷是，我会在群里获得技术提升，每个人都是这样的想法，这个群基本就废了，没人愿意输出，或者是有输出的能力。所以在面对一个产品之前，首先应该思考，你在其中的角色是什么？你想得到什么？这一点完全适用于今天的微信社群、小密圈、知乎 live、得到等产品。</p>
<p>知识付费一直存在，我前文提到的 amoBBS 也可以算是付费社群，只是市场环境更好了，产品的形态更多样化，本质不分轩轾，只不过目前的市场，职业割韭菜的人越来越多，这是必经的过程，被收割的群体本着学习的目的前去，交了学费，学了一招防骗术。</p>
<p>交再多的钱，也不可能变得更有思想，这条路上没有捷径。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请告诉我，你的想法 ？&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://lijundong.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="学习" scheme="http://lijundong.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="web" scheme="http://lijundong.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 变量提升原理解析</title>
    <link href="http://lijundong.com/javascript-variable-lift/"/>
    <id>http://lijundong.com/javascript-variable-lift/</id>
    <published>2017-02-07T05:49:49.000Z</published>
    <updated>2017-02-07T07:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多 Javascript 教程或者书籍中都会介绍 Javascript 的变量提升，但是你了解其中的原因吗？</p>
<a id="more"></a>
<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>首先来看两个经典的案例 （<strong>案例均处于严格模式</strong>）</p>
<p>案例一：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure></p>
<p>这个很简单，变量提升最直接的体现，输出的结果是 <code>1</code>，实际的执行顺序如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></p>
<p>案例二：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>这段代码执行会报错，不过错误是 a 是 <code>undefined</code>，而不是 <code>ReferenceError</code>，因为这段代码的实际执行顺序如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>要弄清楚 Javascript 变量提升，还得回到 Javascript 的编译阶段。</p>
<blockquote>
<p>Part of the compilation phase was to find and associate all declarations with their appropriate scopes.</p>
</blockquote>
<p>编译阶段的其中一个工作就是找到所有的声明，并用合适的作用域将它们关联起来，所有的变量声明以及函数声明都会在代码执行之前首先被处理。所以，分析 Javascript 代码的时候需要先关注声明。<br>这样就导致了 <code>var a = 1;</code> 被分解成了 <code>var a; a = 1;</code>，所以案例二的结果就很明显了。</p>
<h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><p>值得注意的是，变量提升时，<strong>函数声明优先</strong>，函数声明会被首先提升，其次才是变量，具体效果如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行的结果是 <code>1</code>，实际执行流程如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//var foo; //重复声明，被忽略</span></span><br><span class="line">foo();</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>参考：</strong></p>
<ul>
<li><em><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md" target="_blank" rel="external">You Don’t Know JS: Scope &amp; Closures</a></em></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多 Javascript 教程或者书籍中都会介绍 Javascript 的变量提升，但是你了解其中的原因吗？&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://lijundong.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://lijundong.com/tags/javascript/"/>
    
      <category term="scope" scheme="http://lijundong.com/tags/scope/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 插件推荐</title>
    <link href="http://lijundong.com/chrome-extensions-recommend/"/>
    <id>http://lijundong.com/chrome-extensions-recommend/</id>
    <published>2017-02-03T12:52:51.000Z</published>
    <updated>2017-06-26T13:00:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天总结一下你可能还不知道的 Chrome 插件，可能会解决你长久以来的痛点，欢迎补充。</p>
<a id="more"></a>
<h3 id="关于-Chrome"><a href="#关于-Chrome" class="headerlink" title="关于 Chrome"></a>关于 Chrome</h3><p>在一次重装系统之后，安装完 Chrome 之后登陆 Google 账号，亲眼见证了扩展挨个恢复，从来没有一个产品给我这样深刻的记忆，那样的感动难以言表。Chrome 会同步所有正在使用的扩展，包括商城里已经下线的扩展！<br>在 <a href="http://www.lijundong.com/SublimeText-extension-recommend/" target="_blank" rel="external">SublimeText 插件推荐</a> 中提过，我喜欢使用生态更完整的产品，不过在云服务时代 Sublime 的插件无法同步，这就比较尴尬了(曾有个插件试图解决这个痛点，后不了了之)。相比于 Sublime，Chrome 是一个更趋于完美的产品。</p>
<p><strong>当然，你还需要解决墙的问题</strong></p>
<h3 id="扩展推荐"><a href="#扩展推荐" class="headerlink" title="扩展推荐"></a>扩展推荐</h3><p>本想给这些插件分类，但是这样似乎会把简单的事情变得复杂，所以，数量不多，按需所取（排名不分先后）。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" target="_blank" rel="external">live reload</a></strong><br>应用场景：在你的编辑器中安装 livereload 插件（例如 SublimeText），在编辑文件时预览到 Chrome 中，你的编辑器和 Chrome 即可通讯，达到所见即所得的境界。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="external">Proxy SwitchyOmega</a></strong><br>应用场景：轻松管理网络代理，推荐配合 SS 使用。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/%E4%BA%8C%E7%BB%B4%E7%A0%81qr%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8qr-code-generato/pflgjjogbmmcmfhfcnlohagkablhbpmg" target="_blank" rel="external">二维码(QR码)生成器(QR Code Generator)</a></strong><br>应用场景：为当前页面地址生成二维码。</p>
<p><strong><a href="http://www.editthiscookie.com/" target="_blank" rel="external">EditThisCookie</a></strong><br>应用场景：编辑站点 cookie。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/ie-tab/hehijbfgiekmjfkfjpbkbammjbdenadd" target="_blank" rel="external">IE Tab</a></strong><br>应用场景：一键模拟 IE 内核，在一些比较特殊的场景下比较使用，不用特意再去打开 IE。</p>
<p><strong><a href="https://wappalyzer.com/?pk_campaign=chrome&amp;pk_kwd=context" target="_blank" rel="external">Wappalyzer</a></strong><br>应用场景：查看当前网站所用技术栈</p>
<p><strong><a href="http://www.alexa.com/" target="_blank" rel="external">Alexa Rank</a></strong><br>应用场景：查看当前站点的全球 Alexa 排名</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/take-webpage-screenshots/mcbpblocgmgfnpjjppndjkmgjaogfceg" target="_blank" rel="external">Take Webpage Screenshots Entirely</a></strong><br>应用场景：功能强大的网页截图，并且提供 Pro 选项，截图可以存储为 PDF 或者 图片。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/%E6%9E%81%E7%AE%80%E5%9B%BE%E5%BA%8A/heebflcbemenefckkgfnnklbhdbdkagg" target="_blank" rel="external">极简图床</a></strong><br>应用场景：配合七牛账号，轻松上传文件到七牛，管理方便，如果你喜欢使用 Markdown，那么你可以尝试一下。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/save-to-pocket/niloccemoadcdkdjlinkgdfekeahmflj" target="_blank" rel="external">Save to Pocket</a></strong><br>应用场景：稍后阅读，登录 Pocket 账户，全平台同步，方便快捷。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/evernote-web-clipper/pioclpoplcdbaefihamjohnefbikjilc" target="_blank" rel="external">Evernote Web Clipper</a></strong><br>应用场景：使用体验和 Pocket 异曲同工，登录印象笔记，全平台同步剪藏。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="external">OneTab</a></strong><br>应用场景：一键保存并关闭当前窗口的所有 TAB，如果你想关闭当前窗口的所有 TAB，但又想保存下来下次再打开，这无疑是最好的选择，在遇到这个插件之前我都是用书签功能，导致最后留下大量书签。</p>
<p><strong><a href="https://jasonsavard.com/?ref=homepage_url&amp;ext=gmail" target="_blank" rel="external">Checker Plus for Gmail </a></strong><br>应用场景：Gmail 最佳伴侣，登陆 Gmail 账户就可以轻松管理邮件了。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/gighmmpiobklfepjocnamgkkbiglidom" target="_blank" rel="external">Ad Block</a></strong><br>应用场景：过滤广告，地表最强</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="external">Vimium</a></strong><br>应用场景：你试过用 Vim 命令操纵 Chrome 吗，你想试试吗</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca" target="_blank" rel="external">Momentum</a></strong><br>应用场景：给你一个赏心悦目的 New Tab 界面</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/infinity-new-tab/dbfmnekepjoapopniengjbcpnbljalfg" target="_blank" rel="external">Infinity</a></strong><br>应用场景：有些同学不喜欢 Momentum，说我就喜欢功能丰富的，那么 Infinity 肯定适合你，它会提供你一个功能丰富的 New Tab。</p>
<p><strong><a href="https://chrome.google.com/webstore/detail/stylish-custom-themes-for/fjnbnpbmkenffdnngjfgmeleoegfcffe/related" target="_blank" rel="external">Stylish</a></strong><br>应用场景：此扩展可以让网站应用已有的主题，相信我，他能拯救你的审美疲劳。</p>
<p><strong>Better History</strong>：已下线<br>应用场景：给你更好的浏览历史体验，前段时间开始用的，昨天看却下线了</p>
<p><strong>印象笔记·悦读</strong>：已下线<br>应用场景：将网页内容重新排版，给你更舒适的阅读体验，配合印象笔记使用，体验更佳，不知为何也下线了。</p>
<p><strong>欢迎补充！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天总结一下你可能还不知道的 Chrome 插件，可能会解决你长久以来的痛点，欢迎补充。&lt;/p&gt;
    
    </summary>
    
      <category term="工具使用" scheme="http://lijundong.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="chrome" scheme="http://lijundong.com/tags/chrome/"/>
    
      <category term="extension" scheme="http://lijundong.com/tags/extension/"/>
    
  </entry>
  
  <entry>
    <title>inline「一」：从 image 底部白边初识 line-height</title>
    <link href="http://lijundong.com/image-and-line-height/"/>
    <id>http://lijundong.com/image-and-line-height/</id>
    <published>2017-01-16T13:25:28.000Z</published>
    <updated>2017-01-17T16:50:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做一个静态页面时，图片底部出现一条 3px 高度的白边，既不是 margin 也不是 padding，找了好久没能解决，后来才发现与 line-height 相关，问题解决后查缺补漏。<br>这里作下笔记。</p>
<a id="more"></a>
<p>解决问题之前需要理清楚几个概念，基线、line-height、vertical-align、inline 元素。</p>
<h3 id="基线-baseline"><a href="#基线-baseline" class="headerlink" title="基线(baseline)"></a>基线(baseline)</h3><p>基线(Baseline) 是字体排印学中的概念，指的是多数字母排列的基准线，大多字母都沿着红色基线排列，举个例子辅助理解<br><img src="http://source.lijundong.com/17-1-17/23484364-file_1484619667824_4a0a.png" alt=""><br>图中 xHh 字母的下边缘红线就是基线的所在，那么有没有一个特定的条件来定义基线呢？这里有个概念可供参考</p>
<blockquote>
<p>字母x的下边缘(线)就是基线的所在。</p>
</blockquote>
<p><img src="http://source.lijundong.com/17-1-17/82294663-file_1484620885555_15872.png" alt=""></p>
<p>这里又引出了 <a href="https://en.wikipedia.org/wiki/X-height" target="_blank" rel="external">x-height</a> 的概念，此处不表。</p>
<h3 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h3><p>关于 line-height 如何定义的讨论，有说法是两条基线之间的距离，看到这个结论我首先想到第一行的行高如何处理，后来去找了资料，发现两条基线之间的距离即是 line-height 这样的结论并不准确。<br>关于 line-height 的定义，<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/line-height" target="_blank" rel="external">MDN</a> 阐述如下：</p>
<blockquote>
<p>On block level elements, the line-height property specifies the minimum height of line boxes within the element.<br>On non-replaced inline elements, line-height specifies the height that is used to calculate line box height.</p>
</blockquote>
<p>即</p>
<blockquote>
<p>block 元素中， line-height 的值等于元素中高度最低的行框(line box) 的高度值。<br>在 non-replaced inline 元素中，line-height 的值等于行框(line box) 的高度值。</p>
</blockquote>
<p><img src="http://source.lijundong.com/17-1-18/72801786-file_1484669613097_12675.png" alt=""></p>
<p><strong>注：</strong></p>
<blockquote>
<p><strong>replaced element VS non-replaced element</strong></p>
<ul>
<li>replaced element: 例如 img、video、canvas 此类渲染出的内容引用外部的元素</li>
<li>non-replaced element: 渲染自身的 content，<br>例如 <code>&lt;a href=&quot;lijundong.com&quot;&gt;Leeon Blog&lt;/a&gt;</code> 此类，渲染出的内容来自自身。</li>
</ul>
</blockquote>
<h3 id="inline-内联-元素"><a href="#inline-内联-元素" class="headerlink" title="inline(内联) 元素"></a>inline(内联) 元素</h3><p>HTML5 中的常见 inline 元素如下：</p>
<ul>
<li>inline：span、strong、em</li>
<li>inline-block：input、button、textarea、select、img</li>
</ul>
<h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><p>vertical-align 作用于 inline 元素 以及 table-cell 元素，还有 <code>::first-letter</code> 和 <code>::first-line</code>，更多内容可以参见 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align" target="_blank" rel="external">MDN</a></p>
<p>属性分类：</p>
<p>适用于 inline 元素的属性：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* keyword values */</span></span><br><span class="line"><span class="attribute">vertical-align</span>: baseline;  <span class="comment">/*基于基线对齐*/</span></span><br><span class="line"><span class="attribute">vertical-align</span>: sub;</span><br><span class="line"><span class="attribute">vertical-align</span>: super;</span><br><span class="line"><span class="attribute">vertical-align</span>: text-top;</span><br><span class="line"><span class="attribute">vertical-align</span>: text-bottom;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br><span class="line"><span class="attribute">vertical-align</span>: top;</span><br><span class="line"><span class="attribute">vertical-align</span>: bottom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;length&gt; values */</span></span><br><span class="line"><span class="attribute">vertical-align</span>: <span class="number">10em</span>;</span><br><span class="line"><span class="attribute">vertical-align</span>: <span class="number">4px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* &lt;percentage&gt; values */</span></span><br><span class="line"><span class="attribute">vertical-align</span>: <span class="number">20%</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="attribute">vertical-align</span>: inherit;</span><br><span class="line"><span class="attribute">vertical-align</span>: initial;</span><br><span class="line"><span class="attribute">vertical-align</span>: unset;</span><br></pre></td></tr></table></figure></p>
<p>适用于 table-cell 的属性：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span>: top;</span><br><span class="line"><span class="attribute">vertical-align</span>: bottom;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br></pre></td></tr></table></figure></p>
<h3 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h3><p>问题代码示例如下，<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> &gt;</span><span class="css"></span><br><span class="line">    * &#123;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">margin</span>:  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">img</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">div</span> ,<span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"headpic.png"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>代码效果图如下，红框圈出部分为出现的白条<br><img src="http://source.lijundong.com/17-1-18/21458514-file_1484670835947_1531c.jpg" alt=""></p>
<p>通过对代码稍作修改可以轻松看出问题所在，实图如下</p>
<p><img src="http://source.lijundong.com/17-1-18/83589094-file_1484670475410_3d83.jpg" alt=""></p>
<p>有了上面的铺垫，现在回头看遇到的问题，就很简单了，究其原委，首先 img 元素默认对齐方式为 <code>vertical-align: baseline;</code>，这就导致了，baseline 以下的部分被空了出来，显示了背景的白色。</p>
<p>问题找到了，对症下药可得出下面的解决方案：</p>
<ul>
<li><p>根本上消除 img 的对齐方式 —— 块状化：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123; </span><br><span class="line">    <span class="attribute">display</span>: block; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改 img 对齐方式，以下三种均可</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: top;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">vertical-align</span>: bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改行高，行高是两条 baseline 之间的距离，因此可以暴力的让行高消失</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* font-size: 0; 当 line-height 使用数值、百分比或者 rem 定义时也可用这种方式，因为 line-height 参照的是 font-size 的值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>遇到问题多多求证，即便是很常见的问题也会挖出大学问，在求证的过程中也不能尽用拿来主义，多参考 w3c 和 MDN 的文档。<br>写的过程中，修修补补了好几回，关于 vertical-align 的内容讲的很仓促，后面会补上，如果文中表达有误，烦请指出，感谢。</p>
<hr>
<p><em>参考：</em></p>
<ul>
<li><a href="http://www.imooc.com/learn/542" target="_blank" rel="external">CSS深入理解之vertical-align</a></li>
<li><a href="https://www.smashingmagazine.com/2012/12/css-baseline-the-good-the-bad-and-the-ugly/" target="_blank" rel="external">CSS Baseline: The Good, The Bad And The Ugly</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E7%B7%9A" target="_blank" rel="external">基线 wiki</a></li>
<li><a href="http://stackoverflow.com/questions/23247467/how-css-line-height-is-measured" target="_blank" rel="external">How CSS line-height is measured?</a></li>
<li><a href="https://www.w3.org/Talks/2008/0911-CSS-Amsterdam/" target="_blank" rel="external">Understanding the CSS box model</a></li>
<li><a href="http://stackoverflow.com/questions/28363186/inline-elements-and-line-height" target="_blank" rel="external">Inline elements and line-height</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在做一个静态页面时，图片底部出现一条 3px 高度的白边，既不是 margin 也不是 padding，找了好久没能解决，后来才发现与 line-height 相关，问题解决后查缺补漏。&lt;br&gt;这里作下笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="http://lijundong.com/categories/css/"/>
    
    
      <category term="css" scheme="http://lijundong.com/tags/css/"/>
    
      <category term="inline" scheme="http://lijundong.com/tags/inline/"/>
    
      <category term="line-height" scheme="http://lijundong.com/tags/line-height/"/>
    
      <category term="baseline" scheme="http://lijundong.com/tags/baseline/"/>
    
  </entry>
  
  <entry>
    <title>可能是写了篇假的年终总结</title>
    <link href="http://lijundong.com/year-again-2017/"/>
    <id>http://lijundong.com/year-again-2017/</id>
    <published>2017-01-15T12:35:05.000Z</published>
    <updated>2017-01-15T15:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017 年的第一个月已经过了一半，一篇文章都没憋出来，先拿这篇凑数吧<br><a id="more"></a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29393038&auto=0&height=66"></iframe>

<p>来京一月有半，除元旦和几位在北京的高中同学聚过一次，其余时间均在住处与公司之间兜转，回家的车票买在一周后，周五临时和两位相熟的朋友决定四(chi)处(chi)转(he)转(he)。<br>到什刹海后，被友人领去了一家巷子深处的烤肉店，味道胜于之前吃过的所有的烤肉，也刷新了之前因为学校周边的纸上烤肉给烤肉贴上的消极标签，加之老板为人亲切，全程都十分舒心。<br>午饭后沿着完全商业化的巷子无目的地走，顺便给他们俩找厕所，连续找了几处都没找到，其中一处是一小巷，巷内也许是住家或是商铺，可能与公厕的外形太过相似，他俩凭着直觉就走进去，也不顾入口处挂着的内无公厕的标识，我想巷内的人应该经历过游客 DDOS 攻击吧，一堆人不来买东西，在门前晃悠找厕所，哈哈！<br>本想着去后海看看，后来变了主意改去天坛溜达，我对北京的主要景点的印象还停留在七年前，初三毕业时学校组织的旅游。不同的是来的时候是夏天，这次是冬天。我对天坛的印象除了祈年殿，剩下的就是那些坐在回廊长凳上打牌的一群群老人，上次来的时候正值酷夏，天气热得很，但是天坛中却十分凉爽，那些聚在此处打牌的老人，真是惬意啊，从进门开始我便开始找那排回廊，直到看见那群老人还在那里，热闹非凡，中途还打趣说这是老年人聚众赌博，哈哈！会不会这些人中，七年前的那群人里会不会今天也在场的呢，想想也是十分有趣。</p>
<p>万物生老病死，规律使然，这些建筑也是一样。即便已经到了快凋零的年纪，但为了慕名而来的游客，还是被涂上了新世纪的胭脂，汉白玉石阶要么被换了新，要么被盖上了木板保护。<br>当时在小摊上买了一个天坛的木板立体拼图，回家后跟我姐一起拼起来，我爸又在表面涂了一层清漆，看着很好看。</p>
<p><img src="http://source.lijundong.com/17-1-15/45714704-file_1484489002339_ab0a.jpg" alt="天坛"></p>
<p>物理教材上出现的回音壁，大家都在墙边喊，不过效果甚微，可能是请求过多，回音壁宕机了吧，哈哈</p>
<p><img src="http://source.lijundong.com/17-1-15/86359476-file_1484489001885_c66.jpg" alt="回音壁"></p>
<p>估摸到了五点多，晚饭决定回西二旗找家火锅店再吃顿火锅，地铁到了中途，三个人已经十分疲惫，临时决定下车休息下，休息了十分钟又临时决定直接在附近找家火锅店解决晚饭，太任性了。</p>
<p>饭罢，各自回家。一切都非常愉快，除了一件，早晨出门刚换上干净衣服，吃了烤肉和火锅之后，全身都散发着火锅的芬芳，到了家，洗澡洗头，衣服全都得洗，这样的场景已经出现了两次，深受其扰，尤其在这样的冬天。</p>
<hr>
<p>我是严肃的分割线</p>
<p>16 年的事情都比较细碎，很多方向之前就了解过，大多浅尝辄止，这一年多数时间的工作都是修修补补。关于毕业之后去向的问题也迷茫过，像无头苍蝇乱飞乱撞。机缘巧合，来了北京实习，这段时间见了山，见了人，收获有的。</p>
<p>这是 17 年的第一篇，之前很多时候想写，认为内容太过简单或是对于那些知识的认知还不够细致，只好作罢，摄入和产出是成正比的，希望 17 年多多学习，多多产出，更多地考虑原理性问题，而不是一直停留在应用层面。学习一些酷酷的东西，对，就是拿来吹牛的，哈哈。</p>
<p>今年开始，不确定性越来越多，介于好奇与恐惧之间的感觉真是奇妙。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017 年的第一个月已经过了一半，一篇文章都没憋出来，先拿这篇凑数吧&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://lijundong.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="游记" scheme="http://lijundong.com/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="总结" scheme="http://lijundong.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 自定义日志</title>
    <link href="http://lijundong.com/hexo-blog-custom-log/"/>
    <id>http://lijundong.com/hexo-blog-custom-log/</id>
    <published>2016-12-25T06:23:11.000Z</published>
    <updated>2017-03-22T06:48:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这里记录下 Blog 基于 Hexo 和 Next 主题的一些自定义。</p>
<ul>
<li>自定义 url</li>
<li>文末添加版权说明</li>
<li>文末添加推荐文章列表</li>
<li>博客迁移</li>
<li>添加备案信息</li>
<li>添加打赏功能</li>
</ul>
<a id="more"></a>
<h3 id="自定义-url"><a href="#自定义-url" class="headerlink" title="自定义 url"></a>自定义 url</h3><p>关于 url 的格式，建议在博客刚上线的时候就确定好，因为多说评论以及访客数据都是和 url 绑定的，每一次换 url 都意味着之前的多说评论数据和访问数据都会清空，我的的数据已经被清空过两次了，第一次是把 url 从中文更换为 英文，第二次就是这次，我将 url 的格式从 <code>domain/year/month/title</code> 换成了 <code>domain/title</code>，更简洁，也更容易理解链接的内容。</p>
<h4 id="更改方式"><a href="#更改方式" class="headerlink" title="更改方式"></a>更改方式</h4><p>在 Hexo 的配置文件 <code>_config.yml</code> 中<br>更改 <code>permalink:</code> 配置选项为 <code>permalink: :title/</code></p>
<p>关于 Permalinks 更多参数 可以参考官方文档 <a href="https://hexo.io/zh-cn/docs/permalinks.html" target="_blank" rel="external">Permalinks(永久链接)</a></p>
<h3 id="文末添加版权说明（Next-主题）"><a href="#文末添加版权说明（Next-主题）" class="headerlink" title="文末添加版权说明（Next  主题）"></a>文末添加版权说明（Next  主题）</h3><p>最近看后台数据的时候，发现一篇文章被 latex 社区收录了，挺高兴的，只是文章被修改了一些内容，于是想在每篇文末添加一个版权说明，方法很简单。</p>
<h4 id="更改方式-1"><a href="#更改方式-1" class="headerlink" title="更改方式"></a>更改方式</h4><p>首先在 <code>/hexo/themes/next/layout/_macro/post.swig</code> 文件，修改 <code>&lt;footer class=&quot;post-footer&quot;&gt; &lt;/footer&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer class=&quot;post-footer&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &#123;# 添加版权信息 #&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div class=&quot;copyright&quot; style=&quot;clear:both;&quot;&gt;</span><br><span class="line">           &lt;h3&gt;文档信息&lt;/h3&gt;</span><br><span class="line">           &lt;p&gt;&lt;span&gt;文章作者：&lt;/span&gt;&lt;a href=&quot;http://lijundong.com&quot; title=&quot;李俊冬的网络日志&quot;&gt;李俊冬&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">           &lt;p&gt;&lt;span&gt;发表时间：&lt;/span&gt;&#123;&#123; post.date.format(&quot;YYYY-M-D-HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">           &lt;p&gt;&lt;span&gt;文章标题：&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">           &lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;&#123;&#123; post.permalink &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">           &lt;p&gt;&lt;span&gt;版权声明：&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&quot; title=&quot;自由转载-非商用-非衍生-保持署名 (创意共享3.0许可证)&quot;&gt;自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">           &lt;p&gt;&lt;strong&gt;为方便溯源，避免陈旧错误知识的误导，转载请保留以上信息&lt;/strong&gt;&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;# 文末的标签 #&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">        &lt;div class=&quot;post-tags&quot;&gt;</span><br><span class="line">          &#123;% for tag in post.tags %&#125;</span><br><span class="line">            &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;#&#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">          &#123;% endfor %&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">         &#123;# 使用 list_posts 添加了文章列表 #&#125;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;posts-recommend&quot;&gt;</span><br><span class="line">            &lt;h3&gt;更多文章&lt;/h3&gt;</span><br><span class="line">               &#123;&#123; list_posts() &#125;&#125;  </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;# 此处是前后文章导航，因为上面添加了推荐文章列表，我把这一块注释了 #&#125;</span><br><span class="line"></span><br><span class="line">    &#123;# &#123;% if not is_index and (post.prev or post.next) and not navlessPost %&#125;</span><br><span class="line">        &lt;div class=&quot;post-nav&quot;&gt;</span><br><span class="line">          &lt;div class=&quot;post-nav-next post-nav-item&quot;&gt;</span><br><span class="line">            &#123;% if post.next %&#125;</span><br><span class="line">              &lt;a href=&quot;&#123;&#123; url_for(post.next.path) &#125;&#125;&quot; rel=&quot;next&quot; title=&quot;&#123;&#123; post.next.title &#125;&#125;&quot;&gt;</span><br><span class="line">                &lt;i class=&quot;fa fa-chevron-left&quot;&gt;&lt;/i&gt; &#123;&#123; post.next.title &#125;&#125;</span><br><span class="line">              &lt;/a&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;post-nav-prev post-nav-item&quot;&gt;</span><br><span class="line">            &#123;% if post.prev %&#125;</span><br><span class="line">              &lt;a href=&quot;&#123;&#123; url_for(post.prev.path) &#125;&#125;&quot; rel=&quot;prev&quot; title=&quot;&#123;&#123; post.prev.title &#125;&#125;&quot;&gt;</span><br><span class="line">                &#123;&#123;post.prev.title&#125;&#125; &lt;i class=&quot;fa fa-chevron-right&quot;&gt;&lt;/i&gt;</span><br><span class="line">              &lt;/a&gt;</span><br><span class="line">            &#123;% endif %&#125;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125; #&#125;</span><br><span class="line">  &#123;% set isLast = loop.index % page.per_page === 0 %&#125;</span><br><span class="line">  &#123;% if is_index and not isLast %&#125;</span><br><span class="line">    &lt;div class=&quot;post-eof&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/footer&gt;</span><br></pre></td></tr></table></figure>
<h3 id="文末添加推荐文章列表"><a href="#文末添加推荐文章列表" class="headerlink" title="文末添加推荐文章列表"></a>文末添加推荐文章列表</h3><p>我将文末的前后文章导航页去除，通过 <code>list_posts()</code> 方法添加了最近的文章列表</p>
<p>具体代码如下，完整代码可参见上一条完整代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;posts-recommend&quot;&gt;</span><br><span class="line">    &lt;h3&gt;更多文章&lt;/h3&gt;</span><br><span class="line">    &#123;&#123; list_posts() &#125;&#125;  </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>关于 <code>list_posts()</code> 的用法，更多用法可参照官方文档 <a href="https://hexo.io/zh-cn/docs/helpers.html#list-posts" target="_blank" rel="external">list_posts</a></p>
<h3 id="博客迁移"><a href="#博客迁移" class="headerlink" title="博客迁移"></a>博客迁移</h3><h4 id="粗暴复制"><a href="#粗暴复制" class="headerlink" title="粗暴复制"></a>粗暴复制</h4><p>如果你更滑了新的电脑，迁移 hexo 的博客很简单，我的方式是直接复制 hexo 博客目录(不包含 node_modules 和 public 目录)，在新的电脑中执行 <code>npm install hexo-cli -g</code> 安装 hexo，在博客目录下执行 <code>npm install</code> （package.json 中包含所有的依赖信息），如果 node 版本不一致执行 <code>npm rebuild</code> 命令重新编译。git 的相关操作在这里不再赘述。</p>
<h4 id="优雅的云备份"><a href="#优雅的云备份" class="headerlink" title="优雅的云备份"></a>优雅的云备份</h4><p>复制太过简单粗暴，有更优雅的方式，就是当作 git 项目托管在平台上，如果不想作为 public 项目托管的话，可以选择 github 的付费托管或者国内的 coding 平台进行托管。</p>
<p>如果你的主题是 clone 的平台上的开源项目，主题本身就存在版本控制，那么需要知道知道 <a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="external">Git 工具-子模块</a>。</p>
<h3 id="添加备案信息"><a href="#添加备案信息" class="headerlink" title="添加备案信息"></a>添加备案信息</h3><p>我用的是 NEXT 的主题，直接选择修改 <code>themes&gt;next&gt;layout &gt;_partials&gt;footer.swig</code>，追加以下信息，div 中包裹的是备案信息。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;width:100%;height:50"</span>&gt;</span></span><br><span class="line">蜀ICP备16024716号-1</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="添加打赏功能"><a href="#添加打赏功能" class="headerlink" title="添加打赏功能"></a>添加打赏功能</h3><p>在 NEXT 主题配置文件中，添加打赏配置，分别是微信和支付宝的支付二维码</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">reward_comment:</span> 鸡腿还是可乐 ？</span><br><span class="line"><span class="string">wechatpay:</span> <span class="string">http:</span><span class="comment">//source.lijundong.com/17-2-13/59734441-file_1486916997049_2842.png</span></span><br><span class="line"><span class="string">alipay:</span> <span class="string">http:</span><span class="comment">//source.lijundong.com/17-2-13/74686190-file_1486916997175_15cd8.png</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这里记录下 Blog 基于 Hexo 和 Next 主题的一些自定义。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义 url&lt;/li&gt;
&lt;li&gt;文末添加版权说明&lt;/li&gt;
&lt;li&gt;文末添加推荐文章列表&lt;/li&gt;
&lt;li&gt;博客迁移&lt;/li&gt;
&lt;li&gt;添加备案信息&lt;/li&gt;
&lt;li&gt;添加打赏功能&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具使用" scheme="http://lijundong.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="hexo" scheme="http://lijundong.com/tags/hexo/"/>
    
      <category term="next" scheme="http://lijundong.com/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>小记 - Hexo 部署到阿里云服务器</title>
    <link href="http://lijundong.com/note-hexo-deploy-on-server/"/>
    <id>http://lijundong.com/note-hexo-deploy-on-server/</id>
    <published>2016-12-18T15:58:45.000Z</published>
    <updated>2016-12-18T17:18:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天把 hexo blog 迁移到阿里云服务器，全程看别人的文章，每篇文章描述的方式不尽相同，加之软件环境的不同，再加之我的理解能力短板，中间走了好几次弯路，配完之后，对整体过程加深了理解，之后又重新看了 <code>git hook</code> 的文档，结合配置过程，这里做一次小记。<br><a id="more"></a></p>
<blockquote>
<p><strong>注：</strong></p>
<ul>
<li>因为是迁移，所以这篇笔记不会介绍 Hexo 相关用法。</li>
<li>网上详细的教程非常多，这里细节不做详述，只会总结整体流程以及过程中遇到的坑</li>
</ul>
</blockquote>
<p>之前使用 Hexo 部署静态博客到 Github 或者 coding，也没有细究实现原理，但是一直在折腾，后来看到了下面这张图，这是从 <code>hexo d -g</code> 命令一直到浏览器访问到博客页面的整个流程的架构图。<br>在部署之前看懂这张图，部署过程会十分流畅。</p>
<p><img src="http://source.lijundong.com/16-12-19/68486025-file_1482077506840_3562.png" alt=""></p>
<h3 id="流程架构"><a href="#流程架构" class="headerlink" title="流程架构"></a>流程架构</h3><ul>
<li>Hexo 文件结构下，<code>\source</code> 存放所有 <code>markdown</code> 原文件，我们写的文章 存放在 <code>\source\_post</code> 目录下</li>
<li><code>hexo generate</code> 命令将 <code>\source</code> 下的 <code>markdown</code> 文件编译为 <code>html</code> 文件存放到 <code>\public</code> 目录下，并且根据时间、tag、category 等生成了索引页面。</li>
<li><code>hexo deploy</code> 命令将把 <code>\public</code> 目录下内容推到服务器。</li>
<li>现在博文已经在服务器了，只不过是在仓库里，我们将内容 <code>checkout</code> 或者 <code>clone</code> 到某个可以通过 <code>nginx</code> 访问的目录下，例如 <code>\var\www</code>(如无 <code>www</code>，可以新建)，<strong>注意：不要放在用户文录下</strong></li>
<li>通过 <code>nginx</code> 或者其他服务器，将静态站点暴露出去，到这里，所有的核心工作已经完成了</li>
</ul>
<h3 id="DIY"><a href="#DIY" class="headerlink" title="DIY"></a>DIY</h3><p>如果需要 DIY，可以分以下三步走</p>
<ul>
<li>搭建 Git 服务器：中英文链接在文末，可能需要花点时间</li>
<li>编写 <code>post-receive</code> 脚本：中英文链接在文末，这一步，可以简单粗暴</li>
<li>配置 <code>nginx</code>：配置 <code>nginx</code> 服务器，这个也很简单</li>
</ul>
<h3 id="仅供参考"><a href="#仅供参考" class="headerlink" title="仅供参考"></a>仅供参考</h3><p>关于 Git 服务器，可以参考 Git 官网文档，或者是廖雪峰先生的教程，做到正常推拉即可。</p>
<p>关于 <code>git hooks</code>，昨天写的小记 <a href="http://lijundong.com/2016/12/16/git-hooks/">Git Hooks</a>，可以了解下<br>上面我说这一步可以简单粗暴，下面是我的服务器上的 <code>post-receive</code> 脚本，我把代码 从仓库直接 <code>clone</code> 到 <code>/var/www/hexo</code> 目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">unset GIT_DIR</span><br><span class="line">cd /var/www/hexo</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<p>关于 <code>nginx</code> 配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span>  &#123;</span><br><span class="line">    <span class="comment"># 指定端口</span></span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># 绑定域名</span></span><br><span class="line">    <span class="attribute">server_name</span> localhost www.lijundong.com lijundong.com;</span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/domain1.access.log;</span><br><span class="line">    <span class="comment"># 入口文件</span></span><br><span class="line">    <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">    <span class="comment"># 博客路径</span></span><br><span class="line">    <span class="attribute">root</span>  /var/www/hexo;</span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">404</span>   /<span class="number">404</span>.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>教程虽好，且看且学习，知其然，更应知其所以然</p>
<p>晚安！</p>
<p>参考:</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000005723321" target="_blank" rel="external">架构图</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="external">搭建Git服务器 - 廖雪峰</a></li>
<li><a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server" target="_blank" rel="external">Git on the Server - Setting Up the Server</a></li>
<li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81" target="_blank" rel="external">5.4 Git钩子：自定义你的工作流</a></li>
<li><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="external">8.3 Customizing Git - Git Hooks</a></li>
<li><a href="http://lijundong.com/2016/12/16/git-hooks/">Git Hooks</a></li>
<li><a href="http://lijundong.com/2016/10/12/nginx-conficure-domains-to-servers/">Nginx 配置多个Node服务的域名</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天把 hexo blog 迁移到阿里云服务器，全程看别人的文章，每篇文章描述的方式不尽相同，加之软件环境的不同，再加之我的理解能力短板，中间走了好几次弯路，配完之后，对整体过程加深了理解，之后又重新看了 &lt;code&gt;git hook&lt;/code&gt; 的文档，结合配置过程，这里做一次小记。&lt;br&gt;
    
    </summary>
    
      <category term="问题解决" scheme="http://lijundong.com/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="服务器" scheme="http://lijundong.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="hexo" scheme="http://lijundong.com/tags/hexo/"/>
    
      <category term="阿里云" scheme="http://lijundong.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="hook" scheme="http://lijundong.com/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>Git Hooks</title>
    <link href="http://lijundong.com/git-hooks/"/>
    <id>http://lijundong.com/git-hooks/</id>
    <published>2016-12-16T11:25:34.000Z</published>
    <updated>2016-12-18T11:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Git Hooks</code> 是 Git 提供的允许用户自定义的脚本，这些脚本会在特定条件下被触发，我们可以通过自定义脚本来定制 Git。<br>之前迁移博客到阿里云，<code>Git Hooks</code> 就是非常重要的一部分，我在服务器上使用的 Hook 类型是 <code>post-receive</code>，今天把相关部分官方的文档重新看了下，这篇笔记是在官方文档的基础上进行演绎的。<br><a id="more"></a></p>
<h3 id="安装-Hooks"><a href="#安装-Hooks" class="headerlink" title="安装 Hooks"></a>安装 Hooks</h3><p>多数情况下，所有的 hook 放在 <code>.git/hooks</code> 目录下，当我们执行 <code>git init</code> 时，Git 就会将一些示例脚本填充在 <code>.git/hooks</code> 目录下，这些示例脚本命名以 <code>.sample</code> 后缀，默认不执行，如果想执行这些脚本，可以重命名(去掉 <code>.sample</code> 后缀)，也可以自定义脚本，保存在 <code>.git/hooks</code> 目录下，<strong>并且给予脚本执行权限</strong>。</p>
<p><strong>需要注意的是，Hook  不随项目的克隆而进行复制，也不受版本控制的影响。</strong></p>
<p>Hook 根据使用场景可以分为 客户端(本地) Hooks 和服务端 Hooks。不同使用场景下，根据不同触发条件又分为若干类。</p>
<h3 id="客户端-本地-Hook"><a href="#客户端-本地-Hook" class="headerlink" title="客户端(本地) Hook"></a>客户端(本地) Hook</h3><h4 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h4><p>在 <code>git commit</code> 命令之后，这个脚本会首先运行，用来检查提交的快照，检查有没有遗漏，或者检查一些自定义的选项(例如检查代码格式，检查空格等)，当脚本返回非 0 值时，则中断 <code>commit</code>。<br>你也可以通过 <code>git commit --no-verify</code> 命令提交来跳过这个过程。</p>
<p>参数： 无</p>
<h4 id="prepare-commit-msg"><a href="#prepare-commit-msg" class="headerlink" title="prepare-commit-msg"></a>prepare-commit-msg</h4><p>在 <code>commit</code> 过程中需要编辑 <code>commit message</code>，这个脚本会在默认 <code>commit message</code> 生成之后，在你看到编辑器之前运行，通过这个脚本可以修改默认的 <code>commit message</code>。</p>
<p>参数：</p>
<ul>
<li>默认 <code>commit message</code> 文件路劲</li>
<li>提交类型</li>
<li>commit SHA-1(可选)</li>
</ul>
<h4 id="commit-msg"><a href="#commit-msg" class="headerlink" title="commit-msg"></a>commit-msg</h4><p>这个脚本可以用来检验用户编辑的 <code>commit message</code>。可以用来检查 <code>commit message</code> 是否合乎规范。</p>
<p>参数：</p>
<ul>
<li>存放用户编写的 <code>commit message</code> 的临时文件的路劲</li>
</ul>
<h4 id="pre-rebase"><a href="#pre-rebase" class="headerlink" title="pre-rebase"></a>pre-rebase</h4><p>这个脚本会在 <code>git rebase</code> 命令之前运行，在返回非 0 值时，会中断操作。<br>你可以通过这个脚本来禁用 <code>rebase</code>，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># disallow rebasing any commits</span><br><span class="line">echo &quot;pre-rebase: Rebasing is disallowed.&quot;</span><br><span class="line">exit 1</span><br></pre></td></tr></table></figure>
<h3 id="服务端-Hook"><a href="#服务端-Hook" class="headerlink" title="服务端 Hook"></a>服务端 Hook</h3><p>服务端的 Hook 允许我们在 <code>git push</code> 的不同阶段进行操作。</p>
<h4 id="pre-receive"><a href="#pre-receive" class="headerlink" title="pre-receive"></a>pre-receive</h4><p>客户端 push 过来的内容，必须通过这个脚本的检查来判断接受与否。</p>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>这个脚本在代码更新之前执行。<br><code>update</code> 和 <code>pre-receive</code> 很相似，不同的是，如果我们想把代码推到不同分支，那么 <code>pre-receive</code> 只会执行一次，而 <code>update</code> 在每个分支更新之前都会执行一次。</p>
<h4 id="post-receive"><a href="#post-receive" class="headerlink" title="post-receive"></a>post-receive</h4><p><code>post-receive</code> 脚本在所有流程完成之后被触发，前几天迁移博客时才用到，服务器代码库合并了我的 <code>push</code> 后，通过 <code>post-receive</code> 脚本将仓库 <code>clone</code> 到我的博客目录下，以达到更新效果。</p>
<p>参考:</p>
<ul>
<li><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="external">Customizing Git - Git Hooks</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Git Hooks&lt;/code&gt; 是 Git 提供的允许用户自定义的脚本，这些脚本会在特定条件下被触发，我们可以通过自定义脚本来定制 Git。&lt;br&gt;之前迁移博客到阿里云，&lt;code&gt;Git Hooks&lt;/code&gt; 就是非常重要的一部分，我在服务器上使用的 Hook 类型是 &lt;code&gt;post-receive&lt;/code&gt;，今天把相关部分官方的文档重新看了下，这篇笔记是在官方文档的基础上进行演绎的。&lt;br&gt;
    
    </summary>
    
      <category term="工具使用" scheme="http://lijundong.com/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="git" scheme="http://lijundong.com/tags/git/"/>
    
  </entry>
  
</feed>
