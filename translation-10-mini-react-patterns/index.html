<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="【译】React 的 10 种迷你开发模式"/>




  <meta name="keywords" content="react,译文," />




  <link rel="alternate" href="/rss2.xml" title="Leeonfield">




  <link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico?v=2.4.x" />



<link rel="canonical" href="http://lijundong.com/translation-10-mini-react-patterns/"/>


<meta name="description" content="原文地址：10 React mini-patterns对于 React 初学者的一些经验之谈，初次翻译，望多指教。">
<meta name="keywords" content="react,译文">
<meta property="og:type" content="article">
<meta property="og:title" content="【译】React 的 10 种迷你开发模式">
<meta property="og:url" content="http://lijundong.com/translation-10-mini-react-patterns/index.html">
<meta property="og:site_name" content="Leeonfield">
<meta property="og:description" content="原文地址：10 React mini-patterns对于 React 初学者的一些经验之谈，初次翻译，望多指教。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://source.lijundong.com/17-8-3/97066388.jpg">
<meta property="og:image" content="http://source.lijundong.com/17-8-3/93024380.jpg">
<meta property="og:image" content="http://source.lijundong.com/17-8-3/67133232.jpg">
<meta property="og:image" content="http://source.lijundong.com/17-8-3/72770435.jpg">
<meta property="og:image" content="http://source.lijundong.com/17-8-3/79573493.jpg">
<meta property="og:image" content="http://source.lijundong.com/17-8-3/7528192.jpg">
<meta property="og:updated_time" content="2017-11-21T08:03:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【译】React 的 10 种迷你开发模式">
<meta name="twitter:description" content="原文地址：10 React mini-patterns对于 React 初学者的一些经验之谈，初次翻译，望多指教。">
<meta name="twitter:image" content="http://source.lijundong.com/17-8-3/97066388.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.4.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: true,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c6907c4f3552baba34e8ee2c5980996d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




    <title> 【译】React 的 10 种迷你开发模式 · Leeonfield </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Leeonfield</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Leeonfield</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              关于
            
          </a>
        </li>
      
      
        <li class="menu-search">
          <form>
            <i class="iconfont icon-search" id="open-search"></i>
            <input type="text" class="search-input" id="search-input" />
            <i class="iconfont icon-close" id="close-search"></i>
          </form>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          【译】React 的 10 种迷你开发模式
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2017年7月30日
        </span>
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数据传输"><span class="toc-text">1. 数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-修复-HTML-原生-input"><span class="toc-text">2. 修复 HTML 原生 input</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-给-input-绑定唯一-ID-的标签"><span class="toc-text">3. 给 input 绑定唯一 ID 的标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-通过-props-控制-CSS"><span class="toc-text">4. 通过 props 控制 CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用主题"><span class="toc-text">使用主题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用标记"><span class="toc-text">使用标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#设置值"><span class="toc-text">设置值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#举个例子"><span class="toc-text">举个例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-开关组件"><span class="toc-text">5. 开关组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-进入组件内部"><span class="toc-text">6. 进入组件内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-组件的边界"><span class="toc-text">7. 组件的边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-用于格式化文字的组件"><span class="toc-text">8. 用于格式化文字的组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Store-服务于组件"><span class="toc-text">9. Store 服务于组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-不要通过相对路径引入组件"><span class="toc-text">10. 不要通过相对路径引入组件</span></a></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <blockquote>
<p>原文地址：<a href="//hackernoon.com/10-react-mini-patterns-c1da92f068c5">10 React mini-patterns</a><br>对于 React 初学者的一些经验之谈，初次翻译，望多指教。</p>
</blockquote>
<a id="more"></a>
<p>过去几年里，我参与了几个较大的 <code>React</code> 项目，也做了非常多的小项目，在这过程中，我总结了一些 React 常用的开发模式。<br>这些模式是我在 React 入门阶段非常希望看到的，如果你是 <code>React</code> 新手，那你今天算是赚到了，如果你已经是 <code>React</code> 老鸟，不妨看看有哪些模式。本文较长，如果觉得一些介绍比较枯燥（比如 3、6、8、10），可以选择跳过。</p>
<h3 id="1-数据传输"><a href="#1-数据传输" class="headerlink" title="1. 数据传输"></a>1. 数据传输</h3><p>我建议每个 React 初学者都去了解 React 组件向下传递数据（对象、字符串等）的模式，以及传递让子组件传回数据的方法的模式。可以联想救援队将食物与对讲机送抵井底被困矿工。<br>举个例子：<br><img src="//source.lijundong.com/17-8-3/97066388.jpg" alt="" title="Sending data down and up"></p>
<p>图中左右分别是父组件和子组件，你可以想象连接父子组件的这两个属性允许了数据的双向流通。</p>
<p>其实这一条不算真正意义上的开发模式，下面才是。</p>
<h3 id="2-修复-HTML-原生-input"><a href="#2-修复-HTML-原生-input" class="headerlink" title="2. 修复 HTML 原生 input"></a>2. 修复 HTML 原生 input</h3><p>React 和 web 组件的一大好处是，当页面出现 bug，你可以很快定位到问题所在。<br>如果你在考虑页面中使用不同的输入标签，你会发现这些标签的命名大多是无意义，因此，如果我在处理一个包含多个输入的页面时，我首先会处理这个问题。</p>
<p><img src="//source.lijundong.com/17-8-3/93024380.jpg" alt=""></p>
<p>这些输入标签虽然不是纯粹的花架子，但是仍有很多地方可以改进：</p>
<ul>
<li>输入应该通过 <code>onChange</code> 方法返回值，而不是通过 <code>Javascript</code> 事件绑定</li>
<li>保证 <code>onChange</code> 返回值的类型与输入的值类型统一，如果 <code>typeof props.value</code> 是一个 <code>number</code> 类型，应该将 <code>e.target.value</code> 转换成 <code>number</code> 类型再返回</li>
<li>一套 <code>radio</code> 标签和一个 <code>select</code> 标签在功能上都是相同的，唯一的区别只是 UI 的不同，推荐项目中保留一个 <code>&lt;PickOneFromMany /&gt;</code> 组件，可以通过属性 <code>ui=&quot;radio&quot;</code> 或者 <code>ui=&quot;dropDown&quot;</code> 进行控制</li>
</ul>
<p>以上是我处理原生输入标签时用到的方法，你可以选择其他方式，关键是将这些原生标签转换成为你所用，再也不需要忍受那些糟糕的原生输入标签了。</p>
<h3 id="3-给-input-绑定唯一-ID-的标签"><a href="#3-给-input-绑定唯一-ID-的标签" class="headerlink" title="3. 给 input 绑定唯一 ID 的标签"></a>3. 给 input 绑定唯一 ID 的标签</h3><p>关于 <code>input</code> 输入，如果你注重用户体验，你应该给每个 <code>&lt;input&gt;</code> 标签绑定一个 <code>&lt;label&gt;</code>,通过 <code>id</code>/<code>for</code> 属性进行关联。<br>但如果给每一个 <code>input</code> 都想一个独一无二且生动形象的 ID，那样太浪费时间，而且使用随机生成 ID 的方式也不可行，客户端与服务器端生成的 ID 不同，导致校验不通过，这里推荐你创建一个提供增量 ID 的模块，并在 <code>input</code> 组件中使用，如下所示：</p>
<pre><code>class Input extends React.Component {
    constructor(props) {
        super(props);
        this.id = getNextId();
        this.onChange = this.onChange.bind(this);
  }
   onChange(e) {
        this.props.onChange(e.target.value);
  }
   render() {
       return (
       &lt;label htmlFor={this.id}&gt;
           {this.props.label}
           &lt;input
               id={this.id}
               value={this.props.value} 
               onChange={this.onChange}
               /&gt;
               &lt;/label&gt;
           );
      }
}
</code></pre><p>虽然这里解决 ID 的问题，但是这个方案有漏洞，<code>getNextId()</code> 方法每被调用一次，数字会增加，如果是在服务端渲染，这个数字会持续增加到，因此应该在每次渲染之前进行一次重置（每一次网络请求)。因此，一个完整的获取 ID 模块应该是这样：</p>
<pre><code>let count = 1;
export const resetId = () =&gt; {
    count = 1;
}
export const getNextId = () =&gt; {
    return element-id-${count++};
}
</code></pre><h3 id="4-通过-props-控制-CSS"><a href="#4-通过-props-控制-CSS" class="headerlink" title="4. 通过 props 控制 CSS"></a>4. 通过 props 控制 CSS</h3><p>当你想在不同的实例中应用不同的 CSS 样式，你可以通过传入不同的 <code>props</code> 值来控制需要应用的样式。表面上看，这样的操作似乎很简单，但实际应用中往往会出现很多错误。<br>我总结共有三种不同的方式来控制组件的样式：</p>
<h4 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h4><p>借鉴主题的思路，将一系列的 CSS 声明组合在一起，统一成一个主题，在组件中生命组件的主题，例如 <code>primary</code> 按钮以及 <code>secondary</code> 按钮：<br><code>&lt;Button theme=&quot;secondary&quot;&gt;Hello&lt;/Button&gt;</code><br>一个组件中尽量使用一个主题。</p>
<h4 id="使用标记"><a href="#使用标记" class="headerlink" title="使用标记"></a>使用标记</h4><p>也许你的页面中会有一些圆角 <code>button</code>，但这样的风格不符合你已经定义的主题，遇到这种情况，你可能要去找 UI 商量一个统一的方案，或是在元素中添加一个布尔属性，像这样：<br><code>&lt;Button theme=&quot;secondary&quot; rounded&gt;Hello&lt;/Button&gt;</code><br>等同于这种写法：<br><code>&lt;Button theme=&quot;secondary&quot; rounded={true}&gt;Hello&lt;/Button&gt;</code></p>
<h4 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h4><p>当然，你肯定会遇到直接在组建中写 CSS 样式的情况，像这样：<br><code>&lt;Icon width=&quot;25&quot; height=&quot;25&quot; type=&quot;search&quot; /&gt;</code></p>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>设想你现在需要实现一个链接，但现在有三种截然不同的主题，一些链接有下划线，一些没有，就像这样：</p>
<p><img src="//source.lijundong.com/17-8-3/67133232.jpg" alt=""></p>
<p>下面给出我的处理方式：</p>
<pre><code>// demo.jsx
const Link = (props) =&gt; {
  let className = link link--${props.theme}-theme;
  if (!props.underline) className += &apos; link--no-underline&apos;;
  return &lt;a href={props.href} className={className}&gt;{props.children}&lt;/a&gt;;
};
Link.propTypes = {
  theme: PropTypes.oneOf([
&apos;default&apos;, // primary color, no underline
&apos;blend&apos;, // inherit surrounding styles
&apos;primary-button&apos;, // primary color, solid block
  ]),
  underline: PropTypes.bool,
  href: PropTypes.string.isRequired,
  children: PropTypes.oneOfType([
PropTypes.element,
PropTypes.array,
PropTypes.string,
  ]).isRequired,
};
Link.defaultProps = {
  theme: &apos;default&apos;,
  underline: false,
};
</code></pre><p>CSS 代码如下：</p>
<pre><code>// demo.css
.link--default-theme,
.link--blend-theme:hover {
  color: #D84315;
}

.link--blend-theme {
  color: inherit;
}

.link--default-theme:hover,
.link--blend-theme:hover {
  text-decoration: underline;
}

.link--primary-button-theme {
  display: inline-block;
  padding: 12px 25px;
  font-size: 18px;
  background: #D84315;
  color: white;
}

.link--no-underline {
  text-decoration: none;
}
</code></pre><p>你可能注意到我在类名(例如 <code>link-no-underline</code> )中使用了 <code>--</code>，源自于我过去一直以少写 CSS 代码为目标，但后来意识到这是错的。如果样式可以更好地应用在布局中，我更喜欢使用一些双重和多选择器规则集。<br>虽然我之前提过，但我还想再强调一下，扩展一个网站最困难的部分是 CSS 的部分，Javascript 部分都很容易，CSS 开始就写的很混乱，后面维护会非常困难，一入布局深似海。<br>实际项目中，一些 web 开发者往往被 CSS 特异性给难倒了，如果你在浏览网页，不妨查看一下页面中的元素（比如导航栏中的提示图标）是如何用 CSS 实现的。<br>如果你不想打开控制台去找，也可以思考这个元素（比如圆圈中包含数字）的实现样式涉及了哪些 CSS 规则。</p>
<blockquote>
<p>译者注：所说的元素包含在原文站点中</p>
</blockquote>
<p>共有二十三条规则，还不包括从其他十一条规则下集成的规则，其中 <code>line-height</code> 被复写了九次……即便 <code>line-height</code> 是一只猫，也未能幸免于难。</p>
<p><img src="//source.lijundong.com/17-8-3/72770435.jpg" alt=""></p>
<blockquote>
<p>译者注：猫有九命的梗</p>
</blockquote>
<p>使用 React 之后，我们更好地处理页面样式，更周到地决定设计哪些类应用在我们的组件中，将全局设置迁移到 <code>Button.scss</code> 文件中，移除所有对于特异性以及文件顺序的依赖。<br>边注：我梦想有一天，我们再也不需要浏览器对于样式使用的建议。<code>::user-agent-styles: none-whatsoever;</code> 让这样的梦想成为现实。</p>
<h3 id="5-开关组件"><a href="#5-开关组件" class="headerlink" title="5. 开关组件"></a>5. 开关组件</h3><p>开关组件是呈现众多组件之一的组件。可以是用来展示页面的 <code>&lt;Page&gt;</code> 组件或者是 tab 集合中的 tab，也可以是模态组件中的不同模式。<br>我过去习惯使用 switch 语句处理，实际传递到我想要渲染的组件，再从组件本身导出对组件的引用（作为命名导出，作为组件的属性）。<br>现在看来这些都是可怕的方式，我已经解决的一个潜在危险方法是我用一个对象将 prop 值映射到组件中。</p>
<pre><code>import HomePage from &apos;./HomePage.jsx&apos;;
import AboutPage from &apos;./AboutPage.jsx&apos;;
import UserPage from &apos;./UserPage.jsx&apos;;
import FourOhFourPage from &apos;./FourOhFourPage.jsx&apos;;
const PAGES = {
home: HomePage,
about: AboutPage,
user: UserPage,
};
const Page = (props) =&gt; {
const Handler = PAGES[props.page] || FourOhFourPage;
return &lt;Handler {...props} /&gt;
};
Page.propTypes = {
page: PropTypes.oneOf(Object.keys(PAGES)).isRequired,
};
</code></pre><p><code>PAGE</code> 对象中的值可以在 prop 类型中用来捕获开发时错误。当然，我们可以像这样使用 <code>&lt;Page page=&quot;home&quot; /&gt;</code>，如果你将 <code>home</code>、<code>about</code> 和 <code>user</code> 分别提换成 <code>/</code>、<code>/about</code> 以及 <code>／user</code>，那么你就有了半个路由啦。<br>（下一步想法：移除 react-router）</p>
<h3 id="6-进入组件内部"><a href="#6-进入组件内部" class="headerlink" title="6. 进入组件内部"></a>6. 进入组件内部</h3><p>如果你想提高用户体验，不妨试试在页面输入较频繁的输入框添加 <code>autofocus</code>，非常简单，但却可以大大提高用户的使用体验。<br>设想页面中有一个登陆表单，而作为“用户体验高级设计师”的你想在表单的“用户名”输入框中添加一个闪烁的光标，但发现登陆表单显示在模态框中，而 <code>autofocus</code> 属性只能应用在页面加载。<br>现在你该怎么办 ？<br>你可能会用 Javascript 实现，给 <code>input</code> 标签一个 <code>id</code>，再用 <code>document.getElementById(&#39;user-name-input&#39;).focus()</code> 让输入框聚焦。这种方法虽然有效，但不够优雅，你的程序中对字符串匹配的依赖应该越少越好。<br>比较幸运的是，有一种非常简单的方法可以实现这个效果：</p>
<pre><code>class SignInModal extends Component {
  componentDidMount() {
this.InputComponent.focus();
  }
  render() {
return (
  &lt;div&gt;
&lt;label&gt;User name: &lt;/label&gt;
&lt;Input
  ref={comp =&gt; { this.InputComponent = comp; }}
/&gt;
  &lt;/div&gt;
)
  }
}
</code></pre><p>需要注意的是，当你对组件使用 <code>ref</code> 时，是对组件的引用（而不是底层元素），所以你可以访问其方法。</p>
<h3 id="7-组件的边界"><a href="#7-组件的边界" class="headerlink" title="7. 组件的边界"></a>7. 组件的边界</h3><p>设想你正在写一个搜索用户的组件，当你输入的时候，你会看到一列潜在匹配的用户名和头像，就像这样。</p>
<p><img src="//source.lijundong.com/17-8-3/79573493.jpg" alt=""></p>
<p>当你在设计这个组件时，你可能会犹豫，列表中的每一项都属于 <code>SearchSuggestion</code> 组件吗 ？只有几行 HTML 和 CSS 代码，也许不是 ？但我曾经告诉自己：“如果感到疑惑，那就再建一个新组件”。</p>
<p>我如果这样做，就一个单独的组件都没了。相反，只有一个给每个入口返回对应 DOM 的 <code>renderSearchSuggestion</code> 方法，我就生成了如下的结果：</p>
<pre><code>const SearchSuggestions = (props) =&gt; {
  // renderSearchSuggestion() behaves as a pseduo SearchSuggestion component
  // keep it self contained and it should be easy to extract later if needed
  const renderSearchSuggestion = listItem =&gt; (
&lt;li key={listItem.id}&gt;{listItem.name} {listItem.id}&lt;/li&gt;
  );
  return (
&lt;ul&gt;
  {props.listItems.map(renderSearchSuggestion)}
&lt;/ul&gt;
  );
}
</code></pre><p>如果需求变得更复杂或者你想在其他地方使用这个组件，你可以把这段代码复制到新的组件中。</p>
<p>不要过早地组件化，组件不像茶匙，你可以有很多组件。</p>
<p>我的意思不是要你把你觉得应该独立成组件的部分合并到父组件中，而是想让你把那些你认为不应该独立成组件的部分做一些改进，让它看起来和所在的组件更贴合（如果可以的话）。</p>
<h3 id="8-用于格式化文字的组件"><a href="#8-用于格式化文字的组件" class="headerlink" title="8. 用于格式化文字的组件"></a>8. 用于格式化文字的组件</h3><p>当我刚接触 React 时，我觉得组件是一个非常大的东西，一种给 DOM 结构分组的方法，但实际上，组件就像是用于格式化的一种方法。<br>这里有一个 <code>&lt;Price&gt;</code> 组件，输入一个数字会返回一个漂亮的字符串（加上小数点或者 $ 符）。</p>
<pre><code>const Price = (props) =&gt; {
const price = props.children.toLocaleString(&apos;en&apos;, {
  style: props.showSymbol ? &apos;currency&apos; : undefined,
  currency: props.showSymbol ? &apos;USD&apos; : undefined,
  maximumFractionDigits: props.showDecimals ? 2 : 0,
});
return &lt;span className={props.className}&gt;{price}&lt;/span&gt;
};

Price.propTypes = {
  className: React.PropTypes.string,
  children: React.PropTypes.number,
  showDecimals: React.PropTypes.bool,
  showSymbol: React.PropTypes.bool,
};

Price.defaultProps = {
  children: 0,
  showDecimals: true,
  showSymbol: true,
};

const Page = () =&gt; {
  const lambPrice = 1234.567;
  const jetPrice = 999999.99;
  const bootPrice = 34.567;
  return (
&lt;div&gt;
  &lt;p&gt;One lamb is &lt;Price className=&quot;expensive&quot;&gt;{lambPrice}&lt;/Price&gt;&lt;/p&gt;
  &lt;p&gt;One jet is &lt;Price showDecimals={false}&gt;{jetPrice}&lt;/Price&gt;&lt;/p&gt;
  &lt;p&gt;Those gumboots will set ya back &lt;Price showDecimals={false} showSymbol={false}&gt;{bootPrice}&lt;/Price&gt; bucks.&lt;/p&gt;
&lt;/div&gt;
  );
};
</code></pre><p>注意：代码中没有对获取的数字进行校验……</p>
<h3 id="9-Store-服务于组件"><a href="#9-Store-服务于组件" class="headerlink" title="9. Store 服务于组件"></a>9. Store 服务于组件</h3><p>这行代码我已经写过无数遍了（虽然夸张了点）：<br><code>if (props.user.signInStatus === SIGN_IN_STATUSES.SIGNED_IN)...</code><br>最近我意识到，我这样做是不是错了，我想知道的是“用户登录了没”，而不是“用户登录的状态是否等于已登录 ？”<br>对于我的组件而言，他们应该有足够的发展，而不该因为了忧虑这些小事叨扰它们，他们不该管得到的 price 参数是否是 Number 类型，也不应该为了一个参数的 <code>true</code> 或者 <code>false</code> 烦心。<br>如你所见，如果在 <code>store</code> 中定义的数据符合你的组件要求，你的组件就会简洁很多。如我之前所说，bug 隐藏在复杂逻辑之后，你的组件越简洁，出现 bug 的几率就越低。<br>但开发中肯定会遇到一些复杂的场景，关于如何解决这些问题，我这里有几点经验：</p>
<ol>
<li>制定组件的一般结构以及其所需要的数据</li>
<li>设计满足这些需求的 <code>stroe</code></li>
<li>尽量使你传入的数据匹配 <code>stroe</code> 的要求<br>关于最后一点，我建议创建一个单独的模块来完成所有输入数据的格式处理，属性重命名、字符串转数字、对象转数组、Date 字符串转 Date 对象等等。</li>
</ol>
<h3 id="10-不要通过相对路径引入组件"><a href="#10-不要通过相对路径引入组件" class="headerlink" title="10. 不要通过相对路径引入组件"></a>10. 不要通过相对路径引入组件</h3><pre><code>import Button from &apos;../../../../Button/Button.jsx&apos;;
import Icon from &apos;../../../../Icon/Icon.jsx&apos;;
import Footer from &apos;../../Footer/Footer.jsx&apos;;
</code></pre><p>用下面的方式替代上面的引用方式，是不是觉得清爽很多 ？<br>    import {Button, Icon, Footer} from ‘Components’;<br>理论上可以这么做：</p>
<ul>
<li>创建一个 <code>index.js</code> 文件来引用你所有的组件</li>
<li>使用 Webpack 的 <code>resolve.alias</code> 来重定向所有组件到 <code>index</code> 文件<br>我目前还没尝试过这种方法，我打算在先有的项目中拿一个出来转换成这样的组织方式（蛤蛤，骗你的，我一直都是这么做的）。但正如我之前写的代码一样，我后来意识到这种方式是错的，原因如下：</li>
</ul>
<ol>
<li>Webpack 2 中的 <a href="//github.com/webpack/webpack/issues/4160#issuecomment-281236136">resolve.alias</a> 失效了</li>
<li>因为组件不在 <code>node_modules</code> 里，所以这算是一个 <code>eslint</code> 错误</li>
<li>如果你有一个好的 IDE，那么它会知道项目里的所有组件，如果你忘了加一些属性值，它会温馨地提示你添加，你可以通过 <code>cmd</code>/<code>Ctrl</code> + 点击就可以打开这些组件所在的文件。如果用我之前的方式引用组件，那么 IDE 将找不到我的组件的位置，我就失去了这些温馨智能的功能。</li>
</ol>
<p><img src="//source.lijundong.com/17-8-3/7528192.jpg" alt=""></p>
<p>标注：<a href="//medium.com/@hsiungmatt">matthew hsiung</a> 在关于 eslint 和 WebStorm 的 issue 回复下面提供了一个<a href="//medium.com/@hsiungmatt/great-article-917a2f6b718e#.w66jk94ao">解决方案</a></p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>作者: </span>
      <span>leeon</span>
    </p>
    <p class="copyright-item">
      <span>来源: </span>
      <a href="http://lijundong.com">http://lijundong.com</a>
    </p>
    <p class="copyright-item">
      <span>链接: </span>
      <a href="http://lijundong.com/translation-10-mini-react-patterns/">http://lijundong.com/translation-10-mini-react-patterns/</a>
    </p>

    <p class="copyright-item lincese">
      
      本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/react/">react</a>
            
              <a href="/tags/译文/">译文</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/translation-High-Performance-React-3-New-Tools-to-Speed-Up-Your-Apps/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">【译】高性能 React：提高性能的 3 个开发工具</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/good-coder-not-equal-to-good-developer/">
        <span class="next-text nav-default">llog-32</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:leeonfield@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/lijundong" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/rss2.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">leeon</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://lijundong.com/translation-10-mini-react-patterns/';
        this.page.identifier = 'translation-10-mini-react-patterns/';
        this.page.title = '【译】React 的 10 种迷你开发模式';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//http-www-lijundong-com.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  




    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.4.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.4.x"></script>

    
  <script type="text/html" id="search-result">
    <article class="post">
      <header class="post-header">
        <h1 class="post-title">
          <a href="$url$" class="post-link">
            $title$
          </a>
        </h1>
      </header>
      <div class="post-content">
        $content$
        <div class="read-more">
          <a href="$url$" class="read-more-link">
            阅读更多
          </a>
        </div>
      </div>
    </article>
  </script>
  <script type="text/html" id="no-search-result">
    <div class="no-result">
      <h2>No result found!</h2>
    </div>
  </script>
  <script type="text/javascript" src="/js/src/search.js?v=2.4.x"></script>

  </body>
</html>
